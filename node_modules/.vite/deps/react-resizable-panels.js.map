{
  "version": 3,
  "sources": ["../../react-resizable-panels/lib/utils/assert.ts", "../../react-resizable-panels/lib/global/dom/calculateAvailableGroupSize.ts", "../../react-resizable-panels/lib/components/group/sortByElementOffset.ts", "../../react-resizable-panels/lib/utils/isHTMLElement.ts", "../../react-resizable-panels/lib/global/utils/getDistanceBetweenPointAndRect.ts", "../../react-resizable-panels/lib/global/utils/findClosestRect.ts", "../../react-resizable-panels/lib/global/dom/calculateHitRegions.ts", "../../react-resizable-panels/lib/global/styles/convertEmToPixels.ts", "../../react-resizable-panels/lib/global/styles/convertRemToPixels.ts", "../../react-resizable-panels/lib/global/styles/convertVhToPixels.ts", "../../react-resizable-panels/lib/global/styles/convertVwToPixels.ts", "../../react-resizable-panels/lib/global/styles/parseSizeAndUnit.ts", "../../react-resizable-panels/lib/global/styles/sizeStyleToPixels.ts", "../../react-resizable-panels/lib/global/utils/formatLayoutNumber.ts", "../../react-resizable-panels/lib/global/dom/calculatePanelConstraints.ts", "../../react-resizable-panels/lib/utils/EventEmitter.ts", "../../react-resizable-panels/lib/global/utils/layoutNumbersEqual.ts", "../../react-resizable-panels/lib/global/mutableState.ts", "../../react-resizable-panels/lib/utils/isArrayEqual.ts", "../../react-resizable-panels/lib/global/utils/compareLayoutNumbers.ts", "../../react-resizable-panels/lib/global/utils/validatePanelSize.ts", "../../react-resizable-panels/lib/global/utils/adjustLayoutByDelta.ts", "../../react-resizable-panels/lib/global/utils/findSeparatorGroup.ts", "../../react-resizable-panels/lib/global/utils/layoutsEqual.ts", "../../react-resizable-panels/lib/global/utils/validatePanelGroupLayout.ts", "../../react-resizable-panels/lib/global/utils/getImperativeGroupMethods.ts", "../../react-resizable-panels/lib/global/utils/getMountedGroup.ts", "../../react-resizable-panels/lib/global/utils/adjustLayoutForSeparator.ts", "../../react-resizable-panels/lib/global/event-handlers/onDocumentKeyDown.ts", "../../react-resizable-panels/lib/constants.ts", "../../react-resizable-panels/lib/global/utils/findClosetHitRegion.ts", "../../react-resizable-panels/lib/global/utils/isCoarsePointer.ts", "../../react-resizable-panels/lib/utils/isShadowRoot.ts", "../../react-resizable-panels/lib/vendor/stacking-order.ts", "../../react-resizable-panels/lib/global/utils/doRectsIntersect.ts", "../../react-resizable-panels/lib/global/utils/isViableHitTarget.ts", "../../react-resizable-panels/lib/global/utils/findMatchingHitRegions.ts", "../../react-resizable-panels/lib/global/event-handlers/onDocumentPointerDown.ts", "../../react-resizable-panels/lib/global/cursor/getCursorStyle.ts", "../../react-resizable-panels/lib/global/cursor/updateCursorStyle.ts", "../../react-resizable-panels/lib/global/utils/updateActiveHitRegion.ts", "../../react-resizable-panels/lib/global/event-handlers/onDocumentPointerLeave.ts", "../../react-resizable-panels/lib/global/event-handlers/onDocumentPointerMove.ts", "../../react-resizable-panels/lib/global/event-handlers/onDocumentPointerUp.ts", "../../react-resizable-panels/lib/global/utils/calculateDefaultLayout.ts", "../../react-resizable-panels/lib/global/utils/notifyPanelOnResize.ts", "../../react-resizable-panels/lib/global/utils/objectsEqual.ts", "../../react-resizable-panels/lib/global/utils/validateLayoutKeys.ts", "../../react-resizable-panels/lib/global/mountGroup.ts", "../../react-resizable-panels/lib/hooks/useForceUpdate.ts", "../../react-resizable-panels/lib/hooks/useId.ts", "../../react-resizable-panels/lib/hooks/useIsomorphicLayoutEffect.ts", "../../react-resizable-panels/lib/hooks/useStableCallback.ts", "../../react-resizable-panels/lib/hooks/useMergedRefs.ts", "../../react-resizable-panels/lib/hooks/useStableObject.ts", "../../react-resizable-panels/lib/components/panel/constants.ts", "../../react-resizable-panels/lib/components/group/getPanelSizeCssPropertyName.ts", "../../react-resizable-panels/lib/components/group/GroupContext.ts", "../../react-resizable-panels/lib/components/group/useGroupImperativeHandle.ts", "../../react-resizable-panels/lib/components/group/Group.tsx", "../../react-resizable-panels/lib/utils/debounce.ts", "../../react-resizable-panels/lib/components/group/auto-save/getStorageKey.ts", "../../react-resizable-panels/lib/components/group/useDefaultLayout.ts", "../../react-resizable-panels/lib/components/group/useGroupCallbackRef.ts", "../../react-resizable-panels/lib/components/group/useGroupRef.ts", "../../react-resizable-panels/lib/components/group/useGroupContext.ts", "../../react-resizable-panels/lib/global/utils/getImperativePanelMethods.ts", "../../react-resizable-panels/lib/components/panel/usePanelImperativeHandle.ts", "../../react-resizable-panels/lib/components/panel/Panel.tsx", "../../react-resizable-panels/lib/components/panel/usePanelCallbackRef.ts", "../../react-resizable-panels/lib/components/panel/usePanelRef.ts", "../../react-resizable-panels/lib/global/utils/calculateSeparatorAriaValues.ts", "../../react-resizable-panels/lib/components/separator/Separator.tsx"],
  "sourcesContent": ["export function assert(\n  expectedCondition: unknown,\n  message: string = \"Assertion error\"\n): asserts expectedCondition {\n  if (!expectedCondition) {\n    throw Error(message);\n  }\n}\n", "import type { RegisteredGroup } from \"../../components/group/types\";\n\nexport function calculateAvailableGroupSize({\n  group\n}: {\n  group: RegisteredGroup;\n}) {\n  const { orientation, panels } = group;\n\n  return panels.reduce((totalSize, panel) => {\n    totalSize +=\n      orientation === \"horizontal\"\n        ? panel.element.offsetWidth\n        : panel.element.offsetHeight;\n    return totalSize;\n  }, 0);\n}\n", "import type { Orientation } from \"./types\";\n\nexport function sortByElementOffset<\n  Type extends { element: HTMLElement },\n  ReturnType extends Type[]\n>(orientation: Orientation, panelsOrSeparators: Type[]): ReturnType {\n  return panelsOrSeparators.sort(\n    orientation === \"horizontal\" ? horizontalSort : verticalSort\n  ) as ReturnType;\n}\n\nfunction horizontalSort<Type extends { element: HTMLElement }>(\n  a: Type,\n  b: Type\n) {\n  const delta = a.element.offsetLeft - b.element.offsetLeft;\n  if (delta !== 0) {\n    return delta;\n  }\n  return a.element.offsetWidth - b.element.offsetWidth;\n}\n\nfunction verticalSort<Type extends { element: HTMLElement }>(a: Type, b: Type) {\n  const delta = a.element.offsetTop - b.element.offsetTop;\n  if (delta !== 0) {\n    return delta;\n  }\n  return a.element.offsetHeight - b.element.offsetHeight;\n}\n", "// Detects HTMLElement without requiring instanceof and browser globals\nexport function isHTMLElement(value: unknown): value is HTMLElement {\n  return (\n    value !== null &&\n    typeof value === \"object\" &&\n    \"nodeType\" in value &&\n    value.nodeType === Node.ELEMENT_NODE\n  );\n}\n", "import type { Point } from \"../../types\";\n\nexport function getDistanceBetweenPointAndRect(\n  point: Point,\n  rect: DOMRectReadOnly\n) {\n  return {\n    x:\n      point.x >= rect.left && point.x <= rect.right\n        ? 0\n        : Math.min(\n            Math.abs(point.x - rect.left),\n            Math.abs(point.x - rect.right)\n          ),\n    y:\n      point.y >= rect.top && point.y <= rect.bottom\n        ? 0\n        : Math.min(\n            Math.abs(point.y - rect.top),\n            Math.abs(point.y - rect.bottom)\n          )\n  };\n}\n", "import type { Orientation } from \"../../components/group/types\";\nimport { assert } from \"../../utils/assert\";\nimport { getDistanceBetweenPointAndRect } from \"./getDistanceBetweenPointAndRect\";\n\nexport function findClosestRect({\n  orientation,\n  rects,\n  targetRect\n}: {\n  orientation: Orientation;\n  rects: DOMRectReadOnly[];\n  targetRect: DOMRectReadOnly;\n}): DOMRectReadOnly {\n  const centerPoint = {\n    x: targetRect.x + targetRect.width / 2,\n    y: targetRect.y + targetRect.height / 2\n  };\n\n  let closestRect: DOMRectReadOnly | undefined = undefined;\n  let minDistance = Number.MAX_VALUE;\n\n  for (const rect of rects) {\n    const { x, y } = getDistanceBetweenPointAndRect(centerPoint, rect);\n\n    const distance = orientation === \"horizontal\" ? x : y;\n\n    if (distance < minDistance) {\n      minDistance = distance;\n      closestRect = rect;\n    }\n  }\n\n  assert(closestRect, \"No rect found\");\n\n  return closestRect;\n}\n", "import { sortByElementOffset } from \"../../components/group/sortByElementOffset\";\nimport type { RegisteredGroup } from \"../../components/group/types\";\nimport type { RegisteredPanel } from \"../../components/panel/types\";\nimport type { RegisteredSeparator } from \"../../components/separator/types\";\nimport { isHTMLElement } from \"../../utils/isHTMLElement\";\nimport { findClosestRect } from \"../utils/findClosestRect\";\nimport { calculateAvailableGroupSize } from \"./calculateAvailableGroupSize\";\n\ntype PanelsTuple = [panel: RegisteredPanel, panel: RegisteredPanel];\n\nexport type HitRegion = {\n  group: RegisteredGroup;\n  groupSize: number;\n  panels: PanelsTuple;\n  rect: DOMRect;\n  separator?: RegisteredSeparator | undefined;\n};\n\n/**\n * Determines hit regions for a Group; a hit region is either:\n * - 1: An explicit Separator element\n * - 2: The edge of a Panel element that has another Panel beside it\n *\n * This method determines bounding rects of all regions for the particular group.\n */\nexport function calculateHitRegions(group: RegisteredGroup) {\n  const { element: groupElement, orientation, panels, separators } = group;\n\n  // Sort elements by offset before traversing\n  const sortedChildElements: HTMLElement[] = sortByElementOffset(\n    orientation,\n    Array.from(groupElement.children)\n      .filter(isHTMLElement)\n      .map((element) => ({ element: element as HTMLElement }))\n  ).map(({ element }) => element);\n\n  const hitRegions: HitRegion[] = [];\n\n  let hasInterleavedStaticContent = false;\n  let prevPanel: RegisteredPanel | undefined = undefined;\n  let pendingSeparators: RegisteredSeparator[] = [];\n\n  for (const childElement of sortedChildElements) {\n    if (childElement.hasAttribute(\"data-panel\")) {\n      const panelData = panels.find(\n        (current) => current.element === childElement\n      );\n      if (panelData) {\n        if (prevPanel) {\n          const prevRect = prevPanel.element.getBoundingClientRect();\n          const rect = childElement.getBoundingClientRect();\n\n          let pendingRectsOrSeparators: (DOMRect | RegisteredSeparator)[];\n\n          // If an explicit Separator has been rendered, always watch it\n          // Otherwise watch the entire space between the panels\n          // The one caveat is when there are non-interactive element(s) between panels,\n          // in which case we may need to watch individual panel edges\n          if (hasInterleavedStaticContent) {\n            const firstPanelEdgeRect =\n              orientation === \"horizontal\"\n                ? new DOMRect(prevRect.right, prevRect.top, 0, prevRect.height)\n                : new DOMRect(\n                    prevRect.left,\n                    prevRect.bottom,\n                    prevRect.width,\n                    0\n                  );\n            const secondPanelEdgeRect =\n              orientation === \"horizontal\"\n                ? new DOMRect(rect.left, rect.top, 0, rect.height)\n                : new DOMRect(rect.left, rect.top, rect.width, 0);\n\n            switch (pendingSeparators.length) {\n              case 0: {\n                pendingRectsOrSeparators = [\n                  firstPanelEdgeRect,\n                  secondPanelEdgeRect\n                ];\n                break;\n              }\n              case 1: {\n                const separator = pendingSeparators[0];\n                const closestRect = findClosestRect({\n                  orientation,\n                  rects: [prevRect, rect],\n                  targetRect: separator.element.getBoundingClientRect()\n                });\n\n                pendingRectsOrSeparators = [\n                  separator,\n                  closestRect === prevRect\n                    ? secondPanelEdgeRect\n                    : firstPanelEdgeRect\n                ];\n                break;\n              }\n              default: {\n                pendingRectsOrSeparators = pendingSeparators;\n                break;\n              }\n            }\n          } else {\n            if (pendingSeparators.length) {\n              pendingRectsOrSeparators = pendingSeparators;\n            } else {\n              pendingRectsOrSeparators = [\n                orientation === \"horizontal\"\n                  ? new DOMRect(\n                      prevRect.right,\n                      rect.top,\n                      rect.left - prevRect.right,\n                      rect.height\n                    )\n                  : new DOMRect(\n                      rect.left,\n                      prevRect.bottom,\n                      rect.width,\n                      rect.top - prevRect.bottom\n                    )\n              ];\n            }\n          }\n\n          for (const rectOrSeparator of pendingRectsOrSeparators) {\n            hitRegions.push({\n              group,\n              groupSize: calculateAvailableGroupSize({ group }),\n              panels: [prevPanel, panelData],\n              separator:\n                \"width\" in rectOrSeparator ? undefined : rectOrSeparator,\n              rect:\n                \"width\" in rectOrSeparator\n                  ? rectOrSeparator\n                  : rectOrSeparator.element.getBoundingClientRect()\n            });\n          }\n        }\n\n        hasInterleavedStaticContent = false;\n        prevPanel = panelData;\n        pendingSeparators = [];\n      }\n    } else if (childElement.hasAttribute(\"data-separator\")) {\n      const separatorData = separators.find(\n        (current) => current.element === childElement\n      );\n      if (separatorData) {\n        // Separators will be included implicitly in the area between the previous and next panel\n        // It's important to track them though, to handle the scenario of non-interactive group content\n        pendingSeparators.push(separatorData);\n      } else {\n        prevPanel = undefined;\n        pendingSeparators = [];\n      }\n    } else {\n      hasInterleavedStaticContent = true;\n    }\n  }\n\n  return hitRegions;\n}\n", "export function convertEmToPixels(element: Element, value: number) {\n  const style = getComputedStyle(element);\n  const fontSize = parseFloat(style.fontSize);\n\n  return value * fontSize;\n}\n", "export function convertRemToPixels(element: Element, value: number) {\n  const style = getComputedStyle(element.ownerDocument.body);\n  const fontSize = parseFloat(style.fontSize);\n\n  return value * fontSize;\n}\n", "export function convertVhToPixels(value: number) {\n  return (value / 100) * window.innerHeight;\n}\n", "export function convertVwToPixels(value: number) {\n  return (value / 100) * window.innerWidth;\n}\n", "import type { SizeUnit } from \"../../components/panel/types\";\n\nexport function parseSizeAndUnit(\n  size: number | string\n): [numeric: number, size: SizeUnit] {\n  switch (typeof size) {\n    case \"number\": {\n      return [size, \"px\"];\n    }\n    case \"string\": {\n      const numeric = parseFloat(size);\n\n      if (size.endsWith(\"%\")) {\n        return [numeric, \"%\"];\n      } else if (size.endsWith(\"px\")) {\n        return [numeric, \"px\"];\n      } else if (size.endsWith(\"rem\")) {\n        return [numeric, \"rem\"];\n      } else if (size.endsWith(\"em\")) {\n        return [numeric, \"em\"];\n      } else if (size.endsWith(\"vh\")) {\n        return [numeric, \"vh\"];\n      } else if (size.endsWith(\"vw\")) {\n        return [numeric, \"vw\"];\n      }\n\n      return [numeric, \"%\"];\n    }\n  }\n}\n", "import { convertEmToPixels } from \"./convertEmToPixels\";\nimport { convertRemToPixels } from \"./convertRemToPixels\";\nimport { convertVhToPixels } from \"./convertVhToPixels\";\nimport { convertVwToPixels } from \"./convertVwToPixels\";\nimport { parseSizeAndUnit } from \"./parseSizeAndUnit\";\n\nexport function sizeStyleToPixels({\n  groupSize,\n  panelElement,\n  styleProp\n}: {\n  groupSize: number;\n  panelElement: HTMLElement;\n  styleProp: number | string;\n}) {\n  let pixels: number | undefined = undefined;\n\n  const [size, unit] = parseSizeAndUnit(styleProp);\n\n  switch (unit) {\n    case \"%\": {\n      pixels = (size / 100) * groupSize;\n      break;\n    }\n    case \"px\": {\n      pixels = size;\n      break;\n    }\n    case \"rem\": {\n      pixels = convertRemToPixels(panelElement, size);\n      break;\n    }\n    case \"em\": {\n      pixels = convertEmToPixels(panelElement, size);\n      break;\n    }\n    case \"vh\": {\n      pixels = convertVhToPixels(size);\n      break;\n    }\n    case \"vw\": {\n      pixels = convertVwToPixels(size);\n      break;\n    }\n  }\n\n  return pixels;\n}\n", "export function formatLayoutNumber(number: number) {\n  return parseFloat(number.toFixed(3));\n}\n", "import type { RegisteredGroup } from \"../../components/group/types\";\nimport type { PanelConstraints } from \"../../components/panel/types\";\nimport { sizeStyleToPixels } from \"../styles/sizeStyleToPixels\";\nimport { formatLayoutNumber } from \"../utils/formatLayoutNumber\";\nimport { calculateAvailableGroupSize } from \"./calculateAvailableGroupSize\";\n\nexport function calculatePanelConstraints(group: RegisteredGroup) {\n  const { panels } = group;\n\n  const groupSize = calculateAvailableGroupSize({ group });\n  if (groupSize === 0) {\n    // Can't calculate anything meaningful if the group has a width/height of 0\n    // (This could indicate that it's within a hidden subtree)\n    return panels.map((current) => ({\n      collapsedSize: 0,\n      collapsible: current.panelConstraints.collapsible === true,\n      defaultSize: undefined,\n      minSize: 0,\n      maxSize: 100,\n      panelId: current.id\n    }));\n  }\n\n  return panels.map<PanelConstraints>((panel) => {\n    const { element, panelConstraints } = panel;\n\n    let collapsedSize = 0;\n    if (panelConstraints.collapsedSize) {\n      const pixels = sizeStyleToPixels({\n        groupSize,\n        panelElement: element,\n        styleProp: panelConstraints.collapsedSize\n      });\n\n      collapsedSize = formatLayoutNumber((pixels / groupSize) * 100);\n    }\n\n    let defaultSize: number | undefined = undefined;\n    if (panelConstraints.defaultSize) {\n      const pixels = sizeStyleToPixels({\n        groupSize,\n        panelElement: element,\n        styleProp: panelConstraints.defaultSize\n      });\n\n      defaultSize = formatLayoutNumber((pixels / groupSize) * 100);\n    }\n\n    let minSize = 0;\n    if (panelConstraints.minSize) {\n      const pixels = sizeStyleToPixels({\n        groupSize,\n        panelElement: element,\n        styleProp: panelConstraints.minSize\n      });\n\n      minSize = formatLayoutNumber((pixels / groupSize) * 100);\n    }\n\n    let maxSize = 100;\n    if (panelConstraints.maxSize) {\n      const pixels = sizeStyleToPixels({\n        groupSize,\n        panelElement: element,\n        styleProp: panelConstraints.maxSize\n      });\n\n      maxSize = formatLayoutNumber((pixels / groupSize) * 100);\n    }\n\n    return {\n      collapsedSize,\n      collapsible: panelConstraints.collapsible === true,\n      defaultSize,\n      minSize,\n      maxSize,\n      panelId: panel.id\n    };\n  });\n}\n", "export type EventMap = {\n  [key: string]: unknown;\n};\n\nexport type EventListener<Data> = (data: Data) => void;\n\nexport class EventEmitter<Events extends EventMap> {\n  #listenerMap: {\n    [Key in keyof Events]?: EventListener<Events[Key]>[];\n  } = {};\n\n  addListener<Type extends keyof Events>(\n    type: Type,\n    listener: EventListener<Events[Type]>\n  ) {\n    const listeners = this.#listenerMap[type];\n    if (listeners === undefined) {\n      this.#listenerMap[type] = [listener];\n    } else {\n      if (!listeners.includes(listener)) {\n        listeners.push(listener);\n      }\n    }\n\n    return () => {\n      this.removeListener(type, listener);\n    };\n  }\n\n  emit<Type extends keyof Events>(type: Type, data: Events[Type]) {\n    const listeners = this.#listenerMap[type];\n    if (listeners !== undefined) {\n      if (listeners.length === 1) {\n        const listener = listeners[0];\n        listener.call(null, data);\n      } else {\n        let didThrow = false;\n        let caughtError = null;\n\n        // Clone the current listeners before calling\n        // in case calling triggers listeners to be added or removed\n        const clonedListeners = Array.from(listeners);\n        for (let i = 0; i < clonedListeners.length; i++) {\n          const listener = clonedListeners[i];\n          try {\n            listener.call(null, data);\n          } catch (error) {\n            if (caughtError === null) {\n              didThrow = true;\n              caughtError = error;\n            }\n          }\n        }\n\n        if (didThrow) {\n          throw caughtError;\n        }\n      }\n    }\n  }\n\n  removeAllListeners() {\n    this.#listenerMap = {};\n  }\n\n  removeListener<Type extends keyof Events>(\n    type: Type,\n    listener: EventListener<Events[Type]>\n  ) {\n    const listeners = this.#listenerMap[type];\n    if (listeners !== undefined) {\n      const index = listeners.indexOf(listener);\n      if (index >= 0) {\n        listeners.splice(index, 1);\n      }\n    }\n  }\n}\n", "import { formatLayoutNumber } from \"./formatLayoutNumber\";\n\nexport function layoutNumbersEqual(\n  actual: number,\n  expected: number,\n  minimumDelta = 0\n) {\n  return (\n    Math.abs(formatLayoutNumber(actual) - formatLayoutNumber(expected)) <=\n    minimumDelta\n  );\n}\n", "import type { Layout, RegisteredGroup } from \"../components/group/types\";\nimport type {\n  PanelConstraints,\n  RegisteredPanel\n} from \"../components/panel/types\";\nimport type { RegisteredSeparator } from \"../components/separator/types\";\nimport { EventEmitter } from \"../utils/EventEmitter\";\nimport type { InteractionState } from \"./types\";\nimport { layoutNumbersEqual } from \"./utils/layoutNumbersEqual\";\n\ntype UpdaterFunction = (prevState: State) => Partial<State>;\n\nexport type SeparatorToPanelsMap = Map<\n  RegisteredSeparator,\n  [primaryPanel: RegisteredPanel, secondaryPanel: RegisteredPanel]\n>;\n\nexport type MountedGroupMap = Map<\n  RegisteredGroup,\n  {\n    defaultLayoutDeferred: boolean;\n    derivedPanelConstraints: PanelConstraints[];\n    layout: Layout;\n    separatorToPanels: SeparatorToPanelsMap;\n  }\n>;\n\ntype Events = {\n  cursorFlagsChange: number;\n  interactionStateChange: InteractionState;\n  mountedGroupsChange: MountedGroupMap;\n};\n\ntype State = {\n  cursorFlags: number;\n  interactionState: InteractionState;\n  mountedGroups: MountedGroupMap;\n};\n\nlet state: State = {\n  cursorFlags: 0,\n  interactionState: {\n    state: \"inactive\"\n  },\n  mountedGroups: new Map()\n};\n\nexport const eventEmitter = new EventEmitter<Events>();\n\nexport function read(): State {\n  return state;\n}\n\nexport function update(value: Partial<State> | UpdaterFunction) {\n  const partialState = typeof value === \"function\" ? value(state) : value;\n  if (state === partialState) {\n    return state;\n  }\n\n  const prevState = state;\n\n  state = {\n    ...state,\n    ...partialState\n  };\n\n  if (partialState.cursorFlags !== undefined) {\n    eventEmitter.emit(\"cursorFlagsChange\", state.cursorFlags);\n  }\n\n  if (partialState.interactionState !== undefined) {\n    eventEmitter.emit(\"interactionStateChange\", state.interactionState);\n  }\n\n  if (partialState.mountedGroups !== undefined) {\n    // If any collapsible Panels have been collapsed by this size change, record their previous sizes\n    state.mountedGroups.forEach((value, group) => {\n      value.derivedPanelConstraints.forEach((constraints) => {\n        if (constraints.collapsible) {\n          const { layout: prevLayout } =\n            prevState.mountedGroups.get(group) ?? {};\n          if (prevLayout) {\n            const isCollapsed = layoutNumbersEqual(\n              constraints.collapsedSize,\n              value.layout[constraints.panelId]\n            );\n            const wasCollapsed = layoutNumbersEqual(\n              constraints.collapsedSize,\n              prevLayout[constraints.panelId]\n            );\n            if (isCollapsed && !wasCollapsed) {\n              group.inMemoryLastExpandedPanelSizes[constraints.panelId] =\n                prevLayout[constraints.panelId];\n            }\n          }\n        }\n      });\n    });\n\n    eventEmitter.emit(\"mountedGroupsChange\", state.mountedGroups);\n  }\n\n  return state;\n}\n", "export function isArrayEqual(a: number[], b: number[]) {\n  if (a.length !== b.length) {\n    return false;\n  } else {\n    for (let index = 0; index < a.length; index++) {\n      if (a[index] != b[index]) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n", "import { layoutNumbersEqual } from \"./layoutNumbersEqual\";\n\nexport function compareLayoutNumbers(actual: number, expected: number) {\n  if (layoutNumbersEqual(actual, expected)) {\n    return 0;\n  } else {\n    return actual > expected ? 1 : -1;\n  }\n}\n", "import type { PanelConstraints } from \"../../components/panel/types\";\nimport { compareLayoutNumbers } from \"./compareLayoutNumbers\";\nimport { formatLayoutNumber } from \"./formatLayoutNumber\";\n\n// Panel size must be in percentages; pixel values should be pre-converted\nexport function validatePanelSize({\n  panelConstraints,\n  size\n}: {\n  panelConstraints: PanelConstraints;\n  size: number;\n}) {\n  const {\n    collapsedSize = 0,\n    collapsible,\n    maxSize = 100,\n    minSize = 0\n  } = panelConstraints;\n\n  if (compareLayoutNumbers(size, minSize) < 0) {\n    if (collapsible) {\n      // Collapsible panels should snap closed or open only once they cross the halfway point between collapsed and min size.\n      const halfwayPoint = (collapsedSize + minSize) / 2;\n      if (compareLayoutNumbers(size, halfwayPoint) < 0) {\n        size = collapsedSize;\n      } else {\n        size = minSize;\n      }\n    } else {\n      size = minSize;\n    }\n  }\n\n  size = Math.min(maxSize, size);\n  size = formatLayoutNumber(size);\n\n  return size;\n}\n", "import type { Layout } from \"../../components/group/types\";\nimport type { PanelConstraints } from \"../../components/panel/types\";\nimport { assert } from \"../../utils/assert\";\nimport { isArrayEqual } from \"../../utils/isArrayEqual\";\nimport { compareLayoutNumbers } from \"../utils/compareLayoutNumbers\";\nimport { layoutNumbersEqual } from \"../utils/layoutNumbersEqual\";\nimport { validatePanelSize } from \"../utils/validatePanelSize\";\n\n// All units must be in percentages; pixel values should be pre-converted\nexport function adjustLayoutByDelta({\n  delta,\n  initialLayout: initialLayoutProp,\n  panelConstraints: panelConstraintsArray,\n  pivotIndices,\n  prevLayout: prevLayoutProp,\n  trigger\n}: {\n  delta: number;\n  initialLayout: Layout;\n  panelConstraints: PanelConstraints[];\n  pivotIndices: number[];\n  prevLayout: Layout;\n  trigger: \"imperative-api\" | \"keyboard\" | \"mouse-or-touch\";\n}): Layout {\n  if (layoutNumbersEqual(delta, 0)) {\n    return initialLayoutProp;\n  }\n\n  const initialLayout = Object.values(initialLayoutProp);\n  const prevLayout = Object.values(prevLayoutProp);\n  const nextLayout = [...initialLayout];\n\n  const [firstPivotIndex, secondPivotIndex] = pivotIndices;\n  assert(firstPivotIndex != null, \"Invalid first pivot index\");\n  assert(secondPivotIndex != null, \"Invalid second pivot index\");\n\n  let deltaApplied = 0;\n\n  // const DEBUG = [];\n  // DEBUG.push(`adjustLayoutByDelta()`);\n  // DEBUG.push(`  initialLayout: ${initialLayout.join(\", \")}`);\n  // DEBUG.push(`  prevLayout: ${prevLayout.join(\", \")}`);\n  // DEBUG.push(`  delta: ${delta}`);\n  // DEBUG.push(`  pivotIndices: ${pivotIndices.join(\", \")}`);\n  // DEBUG.push(`  trigger: ${trigger}`);\n  // DEBUG.push(\"\");\n\n  // A resizing panel affects the panels before or after it.\n  //\n  // A negative delta means the panel(s) immediately after the separator should grow/expand by decreasing its offset.\n  // Other panels may also need to shrink/contract (and shift) to make room, depending on the min weights.\n  //\n  // A positive delta means the panel(s) immediately before the separator should \"expand\".\n  // This is accomplished by shrinking/contracting (and shifting) one or more of the panels after the separator.\n\n  {\n    // If this is a resize triggered by a keyboard event, our logic for expanding/collapsing is different.\n    // We no longer check the halfway threshold because this may prevent the panel from expanding at all.\n    if (trigger === \"keyboard\") {\n      {\n        // Check if we should expand a collapsed panel\n        const index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n        const panelConstraints = panelConstraintsArray[index];\n        assert(\n          panelConstraints,\n          `Panel constraints not found for index ${index}`\n        );\n\n        const {\n          collapsedSize = 0,\n          collapsible,\n          minSize = 0\n        } = panelConstraints;\n\n        // DEBUG.push(`edge case check 1: ${index}`);\n        // DEBUG.push(`  -> collapsible? ${collapsible}`);\n        if (collapsible) {\n          const prevSize = initialLayout[index];\n          assert(\n            prevSize != null,\n            `Previous layout not found for panel index ${index}`\n          );\n\n          if (layoutNumbersEqual(prevSize, collapsedSize)) {\n            const localDelta = minSize - prevSize;\n            // DEBUG.push(`  -> expand delta: ${localDelta}`);\n\n            if (compareLayoutNumbers(localDelta, Math.abs(delta)) > 0) {\n              delta = delta < 0 ? 0 - localDelta : localDelta;\n              // DEBUG.push(`  -> delta: ${delta}`);\n            }\n          }\n        }\n      }\n\n      {\n        // Check if we should collapse a panel at its minimum size\n        const index = delta < 0 ? firstPivotIndex : secondPivotIndex;\n        const panelConstraints = panelConstraintsArray[index];\n        assert(\n          panelConstraints,\n          `No panel constraints found for index ${index}`\n        );\n\n        const {\n          collapsedSize = 0,\n          collapsible,\n          minSize = 0\n        } = panelConstraints;\n\n        // DEBUG.push(`edge case check 2: ${index}`);\n        // DEBUG.push(`  -> collapsible? ${collapsible}`);\n        if (collapsible) {\n          const prevSize = initialLayout[index];\n          assert(\n            prevSize != null,\n            `Previous layout not found for panel index ${index}`\n          );\n\n          if (layoutNumbersEqual(prevSize, minSize)) {\n            const localDelta = prevSize - collapsedSize;\n            // DEBUG.push(`  -> expand delta: ${localDelta}`);\n\n            if (compareLayoutNumbers(localDelta, Math.abs(delta)) > 0) {\n              delta = delta < 0 ? 0 - localDelta : localDelta;\n              // DEBUG.push(`  -> delta: ${delta}`);\n            }\n          }\n        }\n      }\n    }\n    // DEBUG.push(\"\");\n  }\n\n  {\n    // Pre-calculate max available delta in the opposite direction of our pivot.\n    // This will be the maximum amount we're allowed to expand/contract the panels in the primary direction.\n    // If this amount is less than the requested delta, adjust the requested delta.\n    // If this amount is greater than the requested delta, that's useful information tooâ€“\n    // as an expanding panel might change from collapsed to min size.\n\n    const increment = delta < 0 ? 1 : -1;\n\n    let index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n    let maxAvailableDelta = 0;\n\n    // DEBUG.push(\"pre calc...\");\n    while (true) {\n      const prevSize = initialLayout[index];\n      assert(\n        prevSize != null,\n        `Previous layout not found for panel index ${index}`\n      );\n\n      const maxSafeSize = validatePanelSize({\n        panelConstraints: panelConstraintsArray[index],\n        size: 100\n      });\n      const delta = maxSafeSize - prevSize;\n      // DEBUG.push(`  ${index}: ${prevSize} -> ${maxSafeSize}`);\n\n      maxAvailableDelta += delta;\n      index += increment;\n\n      if (index < 0 || index >= panelConstraintsArray.length) {\n        break;\n      }\n    }\n\n    // DEBUG.push(`  -> max available delta: ${maxAvailableDelta}`);\n    const minAbsDelta = Math.min(Math.abs(delta), Math.abs(maxAvailableDelta));\n    delta = delta < 0 ? 0 - minAbsDelta : minAbsDelta;\n    // DEBUG.push(`  -> adjusted delta: ${delta}`);\n    // DEBUG.push(\"\");\n  }\n\n  {\n    // Delta added to a panel needs to be subtracted from other panels (within the constraints that those panels allow).\n\n    const pivotIndex = delta < 0 ? firstPivotIndex : secondPivotIndex;\n    let index = pivotIndex;\n    while (index >= 0 && index < panelConstraintsArray.length) {\n      const deltaRemaining = Math.abs(delta) - Math.abs(deltaApplied);\n\n      const prevSize = initialLayout[index];\n      assert(\n        prevSize != null,\n        `Previous layout not found for panel index ${index}`\n      );\n\n      const unsafeSize = prevSize - deltaRemaining;\n      const safeSize = validatePanelSize({\n        panelConstraints: panelConstraintsArray[index],\n        size: unsafeSize\n      });\n\n      if (!layoutNumbersEqual(prevSize, safeSize)) {\n        deltaApplied += prevSize - safeSize;\n\n        nextLayout[index] = safeSize;\n\n        if (\n          deltaApplied\n            .toFixed(3)\n            .localeCompare(Math.abs(delta).toFixed(3), undefined, {\n              numeric: true\n            }) >= 0\n        ) {\n          break;\n        }\n      }\n\n      if (delta < 0) {\n        index--;\n      } else {\n        index++;\n      }\n    }\n  }\n  // DEBUG.push(`after 1: ${nextLayout.join(\", \")}`);\n  // DEBUG.push(`  deltaApplied: ${deltaApplied}`);\n  // DEBUG.push(\"\");\n\n  // If we were unable to resize any of the panels panels, return the previous state.\n  // This will essentially bailout and ignore e.g. drags past a panel's boundaries\n  if (isArrayEqual(prevLayout, nextLayout)) {\n    // DEBUG.push(`bailout to previous layout: ${prevLayout.join(\", \")}`);\n    // console.log(DEBUG.join(\"\\n\"));\n\n    return prevLayoutProp;\n  }\n\n  {\n    // Now distribute the applied delta to the panels in the other direction\n    const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;\n\n    const prevSize = initialLayout[pivotIndex];\n    assert(\n      prevSize != null,\n      `Previous layout not found for panel index ${pivotIndex}`\n    );\n\n    const unsafeSize = prevSize + deltaApplied;\n    const safeSize = validatePanelSize({\n      panelConstraints: panelConstraintsArray[pivotIndex],\n      size: unsafeSize\n    });\n\n    // Adjust the pivot panel before, but only by the amount that surrounding panels were able to shrink/contract.\n    nextLayout[pivotIndex] = safeSize;\n\n    // Edge case where expanding or contracting one panel caused another one to change collapsed state\n    if (!layoutNumbersEqual(safeSize, unsafeSize)) {\n      let deltaRemaining = unsafeSize - safeSize;\n\n      const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;\n      let index = pivotIndex;\n      while (index >= 0 && index < panelConstraintsArray.length) {\n        const prevSize = nextLayout[index];\n        assert(\n          prevSize != null,\n          `Previous layout not found for panel index ${index}`\n        );\n\n        const unsafeSize = prevSize + deltaRemaining;\n        const safeSize = validatePanelSize({\n          panelConstraints: panelConstraintsArray[index],\n          size: unsafeSize\n        });\n\n        if (!layoutNumbersEqual(prevSize, safeSize)) {\n          deltaRemaining -= safeSize - prevSize;\n\n          nextLayout[index] = safeSize;\n        }\n\n        if (layoutNumbersEqual(deltaRemaining, 0)) {\n          break;\n        }\n\n        if (delta > 0) {\n          index--;\n        } else {\n          index++;\n        }\n      }\n    }\n  }\n  // DEBUG.push(`after 2: ${nextLayout.join(\", \")}`);\n  // DEBUG.push(`  deltaApplied: ${deltaApplied}`);\n  // DEBUG.push(\"\");\n\n  const totalSize = Object.values(nextLayout).reduce(\n    (total, size) => size + total,\n    0\n  );\n  // DEBUG.push(`total size: ${totalSize}`);\n\n  // If our new layout doesn't add up to 100%, that means the requested delta can't be applied\n  // In that case, fall back to our most recent valid layout\n  // Allow for a small rounding difference, else e.g. 3 panel layouts may never be considered valid\n  if (!layoutNumbersEqual(totalSize, 100, 0.1)) {\n    // DEBUG.push(`bailout to previous layout: ${prevLayout.join(\", \")}`);\n    // console.log(DEBUG.join(\"\\n\"));\n\n    return prevLayoutProp;\n  }\n\n  const prevLayoutKeys = Object.keys(prevLayoutProp);\n\n  // console.log(DEBUG.join(\"\\n\"));\n  return nextLayout.reduce<Layout>((accumulated, current, index) => {\n    accumulated[prevLayoutKeys[index]] = current;\n    return accumulated;\n  }, {});\n}\n", "import { assert } from \"../../utils/assert\";\nimport { read } from \"../mutableState\";\n\nexport function findSeparatorGroup(separatorElement: HTMLElement) {\n  const groupElement = separatorElement.parentElement;\n  assert(groupElement, \"Parent group element not found\");\n\n  const { mountedGroups } = read();\n\n  for (const [group] of mountedGroups) {\n    if (group.element === groupElement) {\n      return group;\n    }\n  }\n\n  throw Error(\"Could not find parent Group for separator element\");\n}\n", "import type { Layout } from \"../../components/group/types\";\nimport { compareLayoutNumbers } from \"./compareLayoutNumbers\";\n\nexport function layoutsEqual(a: Layout, b: Layout): boolean {\n  if (Object.keys(a).length !== Object.keys(b).length) {\n    return false;\n  }\n\n  for (const id in a) {\n    // Edge case: Panel id has been changed\n    if (b[id] === undefined || compareLayoutNumbers(a[id], b[id]) !== 0) {\n      return false;\n    }\n  }\n\n  return true;\n}\n", "import type { Layout } from \"../../components/group/types\";\nimport type { PanelConstraints } from \"../../components/panel/types\";\nimport { assert } from \"../../utils/assert\";\nimport { layoutNumbersEqual } from \"./layoutNumbersEqual\";\nimport { validatePanelSize } from \"./validatePanelSize\";\n\n// All units must be in percentages; pixel values should be pre-converted\nexport function validatePanelGroupLayout({\n  layout,\n  panelConstraints\n}: {\n  layout: Layout;\n  panelConstraints: PanelConstraints[];\n}): Layout {\n  const prevLayout = Object.values(layout);\n  const nextLayout = [...prevLayout];\n\n  const nextLayoutTotalSize = nextLayout.reduce(\n    (accumulated, current) => accumulated + current,\n    0\n  );\n\n  // Validate layout expectations\n  if (nextLayout.length !== panelConstraints.length) {\n    throw Error(\n      `Invalid ${panelConstraints.length} panel layout: ${nextLayout\n        .map((size) => `${size}%`)\n        .join(\", \")}`\n    );\n  } else if (\n    !layoutNumbersEqual(nextLayoutTotalSize, 100) &&\n    nextLayout.length > 0\n  ) {\n    for (let index = 0; index < panelConstraints.length; index++) {\n      const unsafeSize = nextLayout[index];\n      assert(unsafeSize != null, `No layout data found for index ${index}`);\n      const safeSize = (100 / nextLayoutTotalSize) * unsafeSize;\n      nextLayout[index] = safeSize;\n    }\n  }\n\n  let remainingSize = 0;\n\n  // First pass: Validate the proposed layout given each panel's constraints\n  for (let index = 0; index < panelConstraints.length; index++) {\n    const unsafeSize = nextLayout[index];\n    assert(unsafeSize != null, `No layout data found for index ${index}`);\n\n    const safeSize = validatePanelSize({\n      panelConstraints: panelConstraints[index],\n      size: unsafeSize\n    });\n\n    if (unsafeSize != safeSize) {\n      remainingSize += unsafeSize - safeSize;\n\n      nextLayout[index] = safeSize;\n    }\n  }\n\n  // If there is additional, left over space, assign it to any panel(s) that permits it\n  // (It's not worth taking multiple additional passes to evenly distribute)\n  if (!layoutNumbersEqual(remainingSize, 0)) {\n    for (let index = 0; index < panelConstraints.length; index++) {\n      const prevSize = nextLayout[index];\n      assert(prevSize != null, `No layout data found for index ${index}`);\n      const unsafeSize = prevSize + remainingSize;\n      const safeSize = validatePanelSize({\n        panelConstraints: panelConstraints[index],\n        size: unsafeSize\n      });\n\n      if (prevSize !== safeSize) {\n        remainingSize -= safeSize - prevSize;\n        nextLayout[index] = safeSize;\n\n        // Once we've used up the remainder, bail\n        if (layoutNumbersEqual(remainingSize, 0)) {\n          break;\n        }\n      }\n    }\n  }\n\n  const prevLayoutKeys = Object.keys(layout);\n\n  return nextLayout.reduce<Layout>((accumulated, current, index) => {\n    accumulated[prevLayoutKeys[index]] = current;\n    return accumulated;\n  }, {});\n}\n", "import type {\n  GroupImperativeHandle,\n  Layout\n} from \"../../components/group/types\";\nimport { read, update } from \"../mutableState\";\nimport { layoutsEqual } from \"./layoutsEqual\";\nimport { validatePanelGroupLayout } from \"./validatePanelGroupLayout\";\n\nexport function getImperativeGroupMethods({\n  groupId\n}: {\n  groupId: string;\n}): GroupImperativeHandle {\n  const find = () => {\n    const { mountedGroups } = read();\n    for (const [group, value] of mountedGroups) {\n      if (group.id === groupId) {\n        return { group, ...value };\n      }\n    }\n\n    throw Error(`Could not find Group with id \"${groupId}\"`);\n  };\n\n  return {\n    getLayout() {\n      const { defaultLayoutDeferred, layout } = find();\n\n      if (defaultLayoutDeferred) {\n        // This indicates that the Group has not finished mounting yet\n        // Likely because it has been rendered inside of a hidden DOM subtree\n        // Any layout value will not have been validated and so it should not be returned\n        return {};\n      }\n\n      return layout;\n    },\n    setLayout(unsafeLayout: Layout) {\n      const {\n        defaultLayoutDeferred,\n        derivedPanelConstraints,\n        group,\n        layout: prevLayout,\n        separatorToPanels\n      } = find();\n\n      const nextLayout = validatePanelGroupLayout({\n        layout: unsafeLayout,\n        panelConstraints: derivedPanelConstraints\n      });\n\n      if (defaultLayoutDeferred) {\n        // This indicates that the Group has not finished mounting yet\n        // Likely because it has been rendered inside of a hidden DOM subtree\n        // In this case we cannot fully validate the layout, so we shouldn't apply it\n        // It's okay to run the validate function above though,\n        // it will still warn about certain types of errors (e.g. wrong number of panels)\n        return prevLayout;\n      }\n\n      if (!layoutsEqual(prevLayout, nextLayout)) {\n        update((prevState) => ({\n          mountedGroups: new Map(prevState.mountedGroups).set(group, {\n            defaultLayoutDeferred,\n            derivedPanelConstraints,\n            layout: nextLayout,\n            separatorToPanels\n          })\n        }));\n      }\n\n      return nextLayout;\n    }\n  };\n}\n", "import type { RegisteredGroup } from \"../../components/group/types\";\nimport { assert } from \"../../utils/assert\";\nimport { read } from \"../mutableState\";\n\nexport function getMountedGroup(group: RegisteredGroup) {\n  const { mountedGroups } = read();\n\n  const mountedGroup = mountedGroups.get(group);\n  assert(mountedGroup, `Mounted Group ${group.id} not found`);\n\n  return mountedGroup;\n}\n", "import { assert } from \"../../utils/assert\";\nimport { update } from \"../mutableState\";\nimport { adjustLayoutByDelta } from \"./adjustLayoutByDelta\";\nimport { findSeparatorGroup } from \"./findSeparatorGroup\";\nimport { getImperativeGroupMethods } from \"./getImperativeGroupMethods\";\nimport { getMountedGroup } from \"./getMountedGroup\";\nimport { layoutsEqual } from \"./layoutsEqual\";\nimport { validatePanelGroupLayout } from \"./validatePanelGroupLayout\";\n\nexport function adjustLayoutForSeparator(\n  separatorElement: HTMLElement,\n  delta: number\n) {\n  const group = findSeparatorGroup(separatorElement);\n  const mountedGroup = getMountedGroup(group);\n\n  const separator = group.separators.find(\n    (current) => current.element === separatorElement\n  );\n  assert(separator, \"Matching separator not found\");\n\n  const panels = mountedGroup.separatorToPanels.get(separator);\n  assert(panels, \"Matching panels not found\");\n\n  const pivotIndices = panels.map((panel) => group.panels.indexOf(panel));\n\n  const groupAPI = getImperativeGroupMethods({ groupId: group.id });\n  const prevLayout = groupAPI.getLayout();\n\n  const unsafeLayout = adjustLayoutByDelta({\n    delta,\n    initialLayout: prevLayout,\n    panelConstraints: mountedGroup.derivedPanelConstraints,\n    pivotIndices,\n    prevLayout,\n    trigger: \"keyboard\"\n  });\n  const nextLayout = validatePanelGroupLayout({\n    layout: unsafeLayout,\n    panelConstraints: mountedGroup.derivedPanelConstraints\n  });\n\n  if (!layoutsEqual(prevLayout, nextLayout)) {\n    update((prevState) => ({\n      mountedGroups: new Map(prevState.mountedGroups).set(group, {\n        defaultLayoutDeferred: mountedGroup.defaultLayoutDeferred,\n        derivedPanelConstraints: mountedGroup.derivedPanelConstraints,\n        layout: nextLayout,\n        separatorToPanels: mountedGroup.separatorToPanels\n      })\n    }));\n  }\n}\n", "import { assert } from \"../../utils/assert\";\nimport { adjustLayoutForSeparator } from \"../utils/adjustLayoutForSeparator\";\nimport { findSeparatorGroup } from \"../utils/findSeparatorGroup\";\nimport { getMountedGroup } from \"../utils/getMountedGroup\";\n\nexport function onDocumentKeyDown(event: KeyboardEvent) {\n  if (event.defaultPrevented) {\n    return;\n  }\n\n  const separatorElement = event.currentTarget as HTMLElement;\n\n  const group = findSeparatorGroup(separatorElement);\n  if (group.disabled) {\n    return;\n  }\n\n  switch (event.key) {\n    case \"ArrowDown\": {\n      event.preventDefault();\n\n      if (group.orientation === \"vertical\") {\n        adjustLayoutForSeparator(separatorElement, 5);\n      }\n      break;\n    }\n    case \"ArrowLeft\": {\n      event.preventDefault();\n\n      if (group.orientation === \"horizontal\") {\n        adjustLayoutForSeparator(separatorElement, -5);\n      }\n      break;\n    }\n    case \"ArrowRight\": {\n      event.preventDefault();\n\n      if (group.orientation === \"horizontal\") {\n        adjustLayoutForSeparator(separatorElement, 5);\n      }\n      break;\n    }\n    case \"ArrowUp\": {\n      event.preventDefault();\n\n      if (group.orientation === \"vertical\") {\n        adjustLayoutForSeparator(separatorElement, -5);\n      }\n      break;\n    }\n    case \"End\": {\n      event.preventDefault();\n\n      // Moves splitter to the position that gives the primary pane its largest allowed size.\n      // This may completely collapse the secondary pane.\n\n      adjustLayoutForSeparator(separatorElement, 100);\n      break;\n    }\n    case \"Enter\": {\n      event.preventDefault();\n\n      // If the primary pane is not collapsed, collapses the pane.\n      // If the pane is collapsed, restores the splitter to its previous position.\n\n      const group = findSeparatorGroup(separatorElement);\n      const { derivedPanelConstraints, layout, separatorToPanels } =\n        getMountedGroup(group);\n\n      const separator = group.separators.find(\n        (current) => current.element === separatorElement\n      );\n      assert(separator, \"Matching separator not found\");\n\n      const panels = separatorToPanels.get(separator);\n      assert(panels, \"Matching panels not found\");\n\n      const primaryPanel = panels[0];\n      const constraints = derivedPanelConstraints.find(\n        (current) => current.panelId === primaryPanel.id\n      );\n      assert(constraints, \"Panel metadata not found\");\n\n      if (constraints.collapsible) {\n        const prevSize = layout[primaryPanel.id];\n\n        const nextSize =\n          constraints.collapsedSize === prevSize\n            ? (group.inMemoryLastExpandedPanelSizes[primaryPanel.id] ??\n              constraints.minSize)\n            : constraints.collapsedSize;\n\n        adjustLayoutForSeparator(separatorElement, nextSize - prevSize);\n      }\n      break;\n    }\n    case \"F6\": {\n      event.preventDefault();\n\n      // Cycle through window panes.\n\n      const group = findSeparatorGroup(separatorElement);\n\n      const separatorElements = group.separators.map(\n        (separator) => separator.element\n      );\n\n      const index = Array.from(separatorElements).findIndex(\n        (current) => current === event.currentTarget\n      );\n      assert(index !== null, \"Index not found\");\n\n      const nextIndex = event.shiftKey\n        ? index > 0\n          ? index - 1\n          : separatorElements.length - 1\n        : index + 1 < separatorElements.length\n          ? index + 1\n          : 0;\n\n      const nextSeparatorElement = separatorElements[nextIndex] as HTMLElement;\n      nextSeparatorElement.focus();\n      break;\n    }\n    case \"Home\": {\n      event.preventDefault();\n\n      // Moves splitter to the position that gives the primary pane its smallest allowed size.\n      // This may completely collapse the primary pane.\n\n      adjustLayoutForSeparator(separatorElement, -100);\n      break;\n    }\n  }\n}\n", "// Constants used for memoization\nexport const EMPTY_ARRAY: unknown[] = [];\nexport const EMPTY_DOM_RECT: DOMRectReadOnly = {\n  bottom: 0,\n  height: 0,\n  left: 0,\n  right: 0,\n  toJSON: () => {},\n  top: 0,\n  width: 0,\n  x: 0,\n  y: 0\n};\nexport const EMPTY_OBJECT = {};\nexport const EMPTY_POINT = { x: 0, y: 0 };\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const IDENTITY_FUNCTION = (value: any) => value;\nexport const NOOP_FUNCTION = () => {};\n\n// Cursor flags\nexport const CURSOR_FLAG_HORIZONTAL_MIN = 0b0001;\nexport const CURSOR_FLAG_HORIZONTAL_MAX = 0b0010;\nexport const CURSOR_FLAG_VERTICAL_MIN = 0b0100;\nexport const CURSOR_FLAG_VERTICAL_MAX = 0b1000;\n\n// Misc. shared values\nexport const DEFAULT_POINTER_PRECISION = {\n  coarse: 10,\n  precise: 5\n};\n", "import type { Orientation } from \"../../components/group/types\";\nimport type { Point } from \"../../types\";\nimport type { HitRegion } from \"../dom/calculateHitRegions\";\nimport { getDistanceBetweenPointAndRect } from \"./getDistanceBetweenPointAndRect\";\n\nexport function findClosetHitRegion(\n  orientation: Orientation,\n  hitRegions: HitRegion[],\n  point: Point\n) {\n  let closestHitRegion: HitRegion | undefined = undefined;\n  let minDistance = {\n    x: Infinity,\n    y: Infinity\n  };\n\n  for (const hitRegion of hitRegions) {\n    const data = getDistanceBetweenPointAndRect(point, hitRegion.rect);\n    switch (orientation) {\n      case \"horizontal\": {\n        if (data.x <= minDistance.x) {\n          closestHitRegion = hitRegion;\n          minDistance = data;\n        }\n        break;\n      }\n      case \"vertical\": {\n        if (data.y <= minDistance.y) {\n          closestHitRegion = hitRegion;\n          minDistance = data;\n        }\n        break;\n      }\n    }\n  }\n\n  return closestHitRegion\n    ? {\n        distance: minDistance,\n        hitRegion: closestHitRegion\n      }\n    : undefined;\n}\n", "let cached: boolean | undefined = undefined;\n\nexport function isCoarsePointer(): boolean {\n  if (cached === undefined) {\n    if (typeof matchMedia === \"function\") {\n      cached = !!matchMedia(\"(pointer:coarse)\").matches;\n    } else {\n      cached = false;\n    }\n  }\n\n  return cached;\n}\n", "// Detects ShadowRoot without requiring instanceof and browser globals\nexport function isShadowRoot(value: unknown): value is ShadowRoot {\n  return (\n    value !== null &&\n    typeof value === \"object\" &&\n    \"nodeType\" in value &&\n    value.nodeType === Node.DOCUMENT_FRAGMENT_NODE\n  );\n}\n", "// Forked from NPM stacking-order@2.0.0\n// - github.com/Rich-Harris/stacking-order/issues/3\n// - github.com/Rich-Harris/stacking-order/issues/6\n\nimport { assert } from \"../utils/assert\";\nimport { isShadowRoot } from \"../utils/isShadowRoot\";\n\n/**\n * Determine which of two nodes appears in front of the other â€”\n * if `a` is in front, returns 1, otherwise returns -1\n * @param {HTMLElement | SVGElement} a\n * @param {HTMLElement | SVGElement} b\n */\nexport function compare(\n  a: HTMLElement | SVGElement,\n  b: HTMLElement | SVGElement\n): number {\n  if (a === b) throw new Error(\"Cannot compare node with itself\");\n\n  const ancestors = {\n    a: get_ancestors(a),\n    b: get_ancestors(b)\n  };\n\n  let common_ancestor;\n\n  // remove shared ancestors\n  while (ancestors.a.at(-1) === ancestors.b.at(-1)) {\n    a = ancestors.a.pop() as HTMLElement;\n    b = ancestors.b.pop() as HTMLElement;\n\n    common_ancestor = a;\n  }\n\n  assert(\n    common_ancestor,\n    \"Stacking order can only be calculated for elements with a common ancestor\"\n  );\n\n  const z_indexes = {\n    a: get_z_index(find_stacking_context(ancestors.a)),\n    b: get_z_index(find_stacking_context(ancestors.b))\n  };\n\n  if (z_indexes.a === z_indexes.b) {\n    const children = common_ancestor.childNodes;\n\n    const furthest_ancestors = {\n      a: ancestors.a.at(-1),\n      b: ancestors.b.at(-1)\n    };\n\n    let i = children.length;\n    while (i--) {\n      const child = children[i];\n      if (child === furthest_ancestors.a) return 1;\n      if (child === furthest_ancestors.b) return -1;\n    }\n  }\n\n  return Math.sign(z_indexes.a - z_indexes.b);\n}\n\nconst props =\n  /\\b(?:position|zIndex|opacity|transform|webkitTransform|mixBlendMode|filter|webkitFilter|isolation)\\b/;\n\n/** @param {HTMLElement | SVGElement} node */\nfunction is_flex_item(node: HTMLElement | SVGElement) {\n  // @ts-expect-error ParentNode vs Element\n  const display = getComputedStyle(get_parent(node) ?? node).display;\n  return display === \"flex\" || display === \"inline-flex\";\n}\n\n/** @param {HTMLElement | SVGElement} node */\nfunction creates_stacking_context(node: HTMLElement | SVGElement) {\n  const style = getComputedStyle(node);\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context\n  if (style.position === \"fixed\") return true;\n  // Forked to fix upstream bug https://github.com/Rich-Harris/stacking-order/issues/3\n  // if (\n  //   (style.zIndex !== \"auto\" && style.position !== \"static\") ||\n  //   is_flex_item(node)\n  // )\n  if (\n    style.zIndex !== \"auto\" &&\n    (style.position !== \"static\" || is_flex_item(node))\n  )\n    return true;\n  if (+style.opacity < 1) return true;\n  if (\"transform\" in style && style.transform !== \"none\") return true;\n  if (\"webkitTransform\" in style && style.webkitTransform !== \"none\")\n    return true;\n  if (\"mixBlendMode\" in style && style.mixBlendMode !== \"normal\") return true;\n  if (\"filter\" in style && style.filter !== \"none\") return true;\n  if (\"webkitFilter\" in style && style.webkitFilter !== \"none\") return true;\n  if (\"isolation\" in style && style.isolation === \"isolate\") return true;\n  if (props.test(style.willChange)) return true;\n  // @ts-expect-error Unrecognized prop\n  if (style.webkitOverflowScrolling === \"touch\") return true;\n\n  return false;\n}\n\n/** @param {(HTMLElement| SVGElement)[]} nodes */\nfunction find_stacking_context(nodes: (HTMLElement | SVGElement)[]) {\n  let i = nodes.length;\n\n  while (i--) {\n    const node = nodes[i];\n    assert(node, \"Missing node\");\n    if (creates_stacking_context(node)) return node;\n  }\n\n  return null;\n}\n\n/** @param {HTMLElement | SVGElement} node */\nfunction get_z_index(node: HTMLElement | SVGElement | null) {\n  return (node && Number(getComputedStyle(node).zIndex)) || 0;\n}\n\n/** @param {HTMLElement} node */\nfunction get_ancestors(node: HTMLElement | SVGElement | null) {\n  const ancestors = [];\n\n  while (node) {\n    ancestors.push(node);\n    // @ts-expect-error ParentNode vs Element\n    node = get_parent(node);\n  }\n\n  return ancestors; // [ node, ... <body>, <html>, document ]\n}\n\n/** @param {HTMLElement} node */\nfunction get_parent(node: HTMLElement) {\n  const { parentNode } = node;\n  if (isShadowRoot(parentNode)) {\n    return parentNode.host;\n  }\n  return parentNode;\n}\n", "import type { Rect } from \"../../types\";\n\nexport function doRectsIntersect(a: Rect, b: Rect): boolean {\n  return (\n    a.x < b.x + b.width &&\n    a.x + a.width > b.x &&\n    a.y < b.y + b.height &&\n    a.y + a.height > b.y\n  );\n}\n", "import { isHTMLElement } from \"../../utils/isHTMLElement\";\nimport { compare } from \"../../vendor/stacking-order\";\nimport { doRectsIntersect } from \"./doRectsIntersect\";\n\n// This library adds pointer event handlers to the Window for two reasons:\n// 1. It allows detecting when the pointer is \"near\" to a panel border or separator element,\n//    (which can be particularly helpful on touch devices)\n// 2. It allows detecting pointer interactions that apply to multiple, nearby panels/separators\n//    (in the event of e.g. nested groups)\n//\n// Because events are handled at the Window, it's important to detect when another element is \"above\" a separator (e.g. a modal)\n// as this should prevent the separator element from being clicked.\n// This function does that determination.\nexport function isViableHitTarget({\n  groupElement,\n  hitRegion,\n  pointerEventTarget\n}: {\n  groupElement: HTMLElement;\n  hitRegion: DOMRect;\n  pointerEventTarget: EventTarget | null;\n}) {\n  if (\n    !isHTMLElement(pointerEventTarget) ||\n    pointerEventTarget.contains(groupElement) ||\n    groupElement.contains(pointerEventTarget)\n  ) {\n    // Calculating stacking order has a cost;\n    // If either group or element contain the other, the click is safe and we can skip calculating the indices\n    return true;\n  }\n\n  if (compare(pointerEventTarget, groupElement) > 0) {\n    // If the pointer target is above the separator, check for overlap\n    // If they are near each other, but not overlapping, then the separator is still a viable target\n    //\n    // Note that it's not sufficient to compare only the target\n    // The target might be a small element inside of a larger container\n    // (For example, a SPAN or a DIV inside of a larger modal dialog)\n    let currentElement: HTMLElement | SVGElement | null = pointerEventTarget;\n    while (currentElement) {\n      if (currentElement.contains(groupElement)) {\n        return true;\n      } else if (\n        doRectsIntersect(currentElement.getBoundingClientRect(), hitRegion)\n      ) {\n        return false;\n      }\n\n      currentElement = currentElement.parentElement;\n    }\n  }\n\n  return true;\n}\n", "import { DEFAULT_POINTER_PRECISION } from \"../../constants\";\nimport type { MountedGroupMap } from \"../mutableState\";\nimport {\n  calculateHitRegions,\n  type HitRegion\n} from \"../dom/calculateHitRegions\";\nimport { findClosetHitRegion } from \"./findClosetHitRegion\";\nimport { isCoarsePointer } from \"./isCoarsePointer\";\nimport { isViableHitTarget } from \"./isViableHitTarget\";\n\nexport function findMatchingHitRegions(\n  event: PointerEvent,\n  mountedGroups: MountedGroupMap\n): HitRegion[] {\n  const matchingHitRegions: HitRegion[] = [];\n\n  mountedGroups.forEach((_, groupData) => {\n    if (groupData.disabled) {\n      return;\n    }\n\n    const maxDistance = isCoarsePointer()\n      ? DEFAULT_POINTER_PRECISION.coarse\n      : DEFAULT_POINTER_PRECISION.precise;\n\n    const hitRegions = calculateHitRegions(groupData);\n    const match = findClosetHitRegion(groupData.orientation, hitRegions, {\n      x: event.clientX,\n      y: event.clientY\n    });\n\n    if (\n      match &&\n      match.distance.x <= maxDistance &&\n      match.distance.y <= maxDistance &&\n      isViableHitTarget({\n        groupElement: groupData.element,\n        hitRegion: match.hitRegion.rect,\n        pointerEventTarget: event.target\n      })\n    ) {\n      matchingHitRegions.push(match.hitRegion);\n    }\n  });\n\n  return matchingHitRegions;\n}\n", "import type { Layout, RegisteredGroup } from \"../../components/group/types\";\nimport type { RegisteredPanel } from \"../../components/panel/types\";\nimport type { RegisteredSeparator } from \"../../components/separator/types\";\nimport { read, update } from \"../mutableState\";\nimport { findMatchingHitRegions } from \"../utils/findMatchingHitRegions\";\n\nexport function onDocumentPointerDown(event: PointerEvent) {\n  if (event.defaultPrevented) {\n    return;\n  }\n\n  const { mountedGroups } = read();\n\n  const hitRegions = findMatchingHitRegions(event, mountedGroups);\n\n  const groups = new Set<RegisteredGroup>();\n  const panels = new Set<RegisteredPanel>();\n  const separators = new Set<RegisteredSeparator>();\n  const initialLayoutMap = new Map<RegisteredGroup, Layout>();\n\n  let didChangeFocus = false;\n\n  hitRegions.forEach((current) => {\n    groups.add(current.group);\n    current.panels.forEach((panel) => {\n      panels.add(panel);\n    });\n\n    if (current.separator) {\n      separators.add(current.separator);\n\n      if (!didChangeFocus) {\n        didChangeFocus = true;\n\n        current.separator.element.focus();\n      }\n    }\n\n    const match = mountedGroups.get(current.group);\n    if (match) {\n      initialLayoutMap.set(current.group, match.layout);\n    }\n  });\n\n  update({\n    interactionState: {\n      hitRegions,\n      initialLayoutMap,\n      pointerDownAtPoint: { x: event.clientX, y: event.clientY },\n      state: \"active\"\n    }\n  });\n\n  if (hitRegions.length) {\n    event.preventDefault();\n  }\n}\n", "import type { Properties } from \"csstype\";\nimport type { RegisteredGroup } from \"../../components/group/types\";\nimport {\n  CURSOR_FLAG_HORIZONTAL_MAX,\n  CURSOR_FLAG_HORIZONTAL_MIN,\n  CURSOR_FLAG_VERTICAL_MAX,\n  CURSOR_FLAG_VERTICAL_MIN\n} from \"../../constants\";\nimport type { InteractionState } from \"../types\";\n\nexport function getCursorStyle({\n  cursorFlags,\n  groups,\n  state\n}: {\n  cursorFlags: number;\n  groups: RegisteredGroup[];\n  state: InteractionState[\"state\"];\n}): Properties[\"cursor\"] | null {\n  let horizontalCount = 0;\n  let verticalCount = 0;\n\n  switch (state) {\n    case \"active\":\n    case \"hover\": {\n      groups.forEach((group) => {\n        if (group.disableCursor) {\n          return;\n        }\n\n        switch (group.orientation) {\n          case \"horizontal\": {\n            horizontalCount++;\n            break;\n          }\n          case \"vertical\": {\n            verticalCount++;\n            break;\n          }\n        }\n      });\n    }\n  }\n\n  if (horizontalCount === 0 && verticalCount === 0) {\n    return null;\n  }\n\n  switch (state) {\n    case \"active\": {\n      const horizontalMin = (cursorFlags & CURSOR_FLAG_HORIZONTAL_MIN) !== 0;\n      const horizontalMax = (cursorFlags & CURSOR_FLAG_HORIZONTAL_MAX) !== 0;\n      const verticalMin = (cursorFlags & CURSOR_FLAG_VERTICAL_MIN) !== 0;\n      const verticalMax = (cursorFlags & CURSOR_FLAG_VERTICAL_MAX) !== 0;\n\n      if (cursorFlags) {\n        if (horizontalMin) {\n          if (verticalMin) {\n            return \"se-resize\";\n          } else if (verticalMax) {\n            return \"ne-resize\";\n          } else {\n            return \"e-resize\";\n          }\n        } else if (horizontalMax) {\n          if (verticalMin) {\n            return \"sw-resize\";\n          } else if (verticalMax) {\n            return \"nw-resize\";\n          } else {\n            return \"w-resize\";\n          }\n        } else if (verticalMin) {\n          return \"s-resize\";\n        } else if (verticalMax) {\n          return \"n-resize\";\n        }\n      }\n      break;\n    }\n  }\n\n  if (horizontalCount > 0 && verticalCount > 0) {\n    return \"move\";\n  } else if (horizontalCount > 0) {\n    return \"ew-resize\";\n  } else {\n    return \"ns-resize\";\n  }\n}\n", "import { read } from \"../mutableState\";\nimport { getCursorStyle } from \"./getCursorStyle\";\n\nconst documentToStyleMap = new WeakMap<\n  Document,\n  {\n    prevStyle: string | undefined;\n    styleSheet: CSSStyleSheet;\n  }\n>();\n\nexport function updateCursorStyle(ownerDocument: Document) {\n  // NOTE undefined is not technically a valid value but it has been reported that it is present in some environments (Vite HMR?)\n  // See github.com/bvaughn/react-resizable-panels/issues/559\n  if (\n    ownerDocument.defaultView === null ||\n    ownerDocument.defaultView === undefined\n  ) {\n    return;\n  }\n\n  let { prevStyle, styleSheet } = documentToStyleMap.get(ownerDocument) ?? {};\n\n  if (styleSheet === undefined) {\n    styleSheet = new ownerDocument.defaultView.CSSStyleSheet();\n\n    ownerDocument.adoptedStyleSheets = [styleSheet];\n  }\n\n  const { cursorFlags, interactionState } = read();\n\n  switch (interactionState.state) {\n    case \"active\":\n    case \"hover\": {\n      const cursorStyle = getCursorStyle({\n        cursorFlags,\n        groups: interactionState.hitRegions.map((current) => current.group),\n        state: interactionState.state\n      });\n\n      const nextStyle = `*{cursor: ${cursorStyle} !important; ${interactionState.state === \"active\" ? \"touch-action: none;\" : \"\"} }`;\n      if (prevStyle === nextStyle) {\n        return;\n      }\n\n      prevStyle = nextStyle;\n\n      if (cursorStyle) {\n        if (styleSheet.cssRules.length === 0) {\n          styleSheet.insertRule(nextStyle);\n        } else {\n          styleSheet.replaceSync(nextStyle);\n        }\n      } else if (styleSheet.cssRules.length === 1) {\n        styleSheet.deleteRule(0);\n      }\n      break;\n    }\n    case \"inactive\": {\n      prevStyle = undefined;\n\n      if (styleSheet.cssRules.length === 1) {\n        styleSheet.deleteRule(0);\n      }\n      break;\n    }\n  }\n\n  documentToStyleMap.set(ownerDocument, {\n    prevStyle,\n    styleSheet\n  });\n}\n", "import type { Layout, RegisteredGroup } from \"../../components/group/types\";\nimport {\n  CURSOR_FLAG_HORIZONTAL_MAX,\n  CURSOR_FLAG_HORIZONTAL_MIN,\n  CURSOR_FLAG_VERTICAL_MAX,\n  CURSOR_FLAG_VERTICAL_MIN\n} from \"../../constants\";\nimport type { Point } from \"../../types\";\nimport { updateCursorStyle } from \"../cursor/updateCursorStyle\";\nimport type { HitRegion } from \"../dom/calculateHitRegions\";\nimport { update, type MountedGroupMap } from \"../mutableState\";\nimport { adjustLayoutByDelta } from \"./adjustLayoutByDelta\";\nimport { layoutsEqual } from \"./layoutsEqual\";\n\nexport function updateActiveHitRegions({\n  document,\n  event,\n  hitRegions,\n  initialLayoutMap,\n  mountedGroups,\n  pointerDownAtPoint\n}: {\n  document: Document;\n  event: {\n    clientX: number;\n    clientY: number;\n  };\n  hitRegions: HitRegion[];\n  initialLayoutMap: Map<RegisteredGroup, Layout>;\n  mountedGroups: MountedGroupMap;\n  pointerDownAtPoint?: Point;\n}) {\n  let cursorFlags = 0;\n  const nextMountedGroups = new Map(mountedGroups);\n\n  // Note that HitRegions are frozen once a drag has started\n  // Modify the Group layouts for all matching HitRegions though\n  hitRegions.forEach((current) => {\n    const { group, groupSize } = current;\n    const { disableCursor, orientation, panels } = group;\n\n    let deltaAsPercentage = 0;\n    if (pointerDownAtPoint) {\n      if (orientation === \"horizontal\") {\n        deltaAsPercentage =\n          ((event.clientX - pointerDownAtPoint.x) / groupSize) * 100;\n      } else {\n        deltaAsPercentage =\n          ((event.clientY - pointerDownAtPoint.y) / groupSize) * 100;\n      }\n    } else {\n      if (orientation === \"horizontal\") {\n        deltaAsPercentage = event.clientX < 0 ? -100 : 100;\n      } else {\n        deltaAsPercentage = event.clientY < 0 ? -100 : 100;\n      }\n    }\n\n    const initialLayout = initialLayoutMap.get(group);\n\n    const {\n      defaultLayoutDeferred,\n      derivedPanelConstraints,\n      layout: prevLayout,\n      separatorToPanels\n    } = mountedGroups.get(group) ?? { defaultLayoutDeferred: false };\n    if (\n      derivedPanelConstraints &&\n      initialLayout &&\n      prevLayout &&\n      separatorToPanels\n    ) {\n      const nextLayout = adjustLayoutByDelta({\n        delta: deltaAsPercentage,\n        initialLayout,\n        panelConstraints: derivedPanelConstraints,\n        pivotIndices: current.panels.map((panel) => panels.indexOf(panel)),\n        prevLayout,\n        trigger: \"mouse-or-touch\"\n      });\n\n      if (layoutsEqual(nextLayout, prevLayout)) {\n        if (deltaAsPercentage !== 0 && !disableCursor) {\n          // An unchanged means the cursor has exceeded the allowed bounds\n          switch (orientation) {\n            case \"horizontal\": {\n              cursorFlags |=\n                deltaAsPercentage < 0\n                  ? CURSOR_FLAG_HORIZONTAL_MIN\n                  : CURSOR_FLAG_HORIZONTAL_MAX;\n              break;\n            }\n            case \"vertical\": {\n              cursorFlags |=\n                deltaAsPercentage < 0\n                  ? CURSOR_FLAG_VERTICAL_MIN\n                  : CURSOR_FLAG_VERTICAL_MAX;\n              break;\n            }\n          }\n        }\n      } else {\n        nextMountedGroups.set(current.group, {\n          defaultLayoutDeferred,\n          derivedPanelConstraints: derivedPanelConstraints,\n          layout: nextLayout,\n          separatorToPanels\n        });\n\n        // Save the most recent layout for this group of panels in-memory\n        // so that layouts will be remembered between different sets of conditionally rendered panels\n        const panelIdsKey = current.group.panels.map(({ id }) => id).join(\",\");\n        current.group.inMemoryLayouts[panelIdsKey] = nextLayout;\n      }\n    }\n  });\n\n  update({\n    cursorFlags,\n    mountedGroups: nextMountedGroups\n  });\n\n  updateCursorStyle(document);\n}\n", "import { read } from \"../mutableState\";\nimport { updateActiveHitRegions } from \"../utils/updateActiveHitRegion\";\n\nexport function onDocumentPointerLeave(event: PointerEvent) {\n  const { interactionState, mountedGroups } = read();\n\n  switch (interactionState.state) {\n    case \"active\": {\n      updateActiveHitRegions({\n        document: event.currentTarget as Document,\n        event,\n        hitRegions: interactionState.hitRegions,\n        initialLayoutMap: interactionState.initialLayoutMap,\n        mountedGroups\n      });\n    }\n  }\n}\n", "import { updateCursorStyle } from \"../cursor/updateCursorStyle\";\nimport { read, update } from \"../mutableState\";\nimport { findMatchingHitRegions } from \"../utils/findMatchingHitRegions\";\nimport { updateActiveHitRegions } from \"../utils/updateActiveHitRegion\";\n\nexport function onDocumentPointerMove(event: PointerEvent) {\n  if (event.defaultPrevented) {\n    return;\n  }\n\n  const { interactionState, mountedGroups } = read();\n\n  switch (interactionState.state) {\n    case \"active\": {\n      // Edge case (see #340)\n      // Detect when the pointer has been released outside an iframe on a different domain\n      if (\n        // Skip this check for \"pointerleave\" events, else Firefox triggers a false positive (see #514)\n        event.buttons === 0\n      ) {\n        update((prevState) =>\n          prevState.interactionState.state === \"inactive\"\n            ? prevState\n            : {\n                cursorFlags: 0,\n                interactionState: {\n                  state: \"inactive\"\n                }\n              }\n        );\n\n        return;\n      }\n\n      updateActiveHitRegions({\n        document: event.currentTarget as Document,\n        event,\n        hitRegions: interactionState.hitRegions,\n        initialLayoutMap: interactionState.initialLayoutMap,\n        mountedGroups,\n        pointerDownAtPoint: interactionState.pointerDownAtPoint\n      });\n      break;\n    }\n    default: {\n      // Update HitRegions if a drag has not been started\n      const hitRegions = findMatchingHitRegions(event, mountedGroups);\n\n      if (hitRegions.length === 0) {\n        if (interactionState.state !== \"inactive\") {\n          update({\n            interactionState: { state: \"inactive\" }\n          });\n        }\n      } else {\n        update({\n          interactionState: {\n            hitRegions,\n            state: \"hover\"\n          }\n        });\n      }\n\n      updateCursorStyle(event.currentTarget as Document);\n      break;\n    }\n  }\n}\n", "import { updateCursorStyle } from \"../cursor/updateCursorStyle\";\nimport { read, update } from \"../mutableState\";\n\nexport function onDocumentPointerUp(event: PointerEvent) {\n  if (event.defaultPrevented) {\n    return;\n  }\n\n  event.preventDefault();\n\n  const { interactionState } = read();\n\n  switch (interactionState.state) {\n    case \"active\": {\n      update({\n        cursorFlags: 0,\n        interactionState: {\n          state: \"inactive\"\n        }\n      });\n\n      updateCursorStyle(event.currentTarget as Document);\n    }\n  }\n}\n", "import type { Layout } from \"../../components/group/types\";\nimport type { PanelConstraints } from \"../../components/panel/types\";\nimport { formatLayoutNumber } from \"./formatLayoutNumber\";\n\nexport function calculateDefaultLayout(\n  derivedPanelConstraints: PanelConstraints[]\n): Layout {\n  let explicitCount = 0;\n  let total = 0;\n\n  const layout: Layout = {};\n\n  for (const current of derivedPanelConstraints) {\n    if (current.defaultSize !== undefined) {\n      explicitCount++;\n\n      const size = formatLayoutNumber(current.defaultSize);\n\n      total += size;\n      layout[current.panelId] = size;\n    } else {\n      // @ts-expect-error Add panel keys in order to simplify traversal elsewhere; we'll fill them in in the loop below\n      layout[current.panelId] = undefined;\n    }\n  }\n\n  const remainingPanelCount = derivedPanelConstraints.length - explicitCount;\n  if (remainingPanelCount !== 0) {\n    const size = formatLayoutNumber((100 - total) / remainingPanelCount);\n\n    for (const current of derivedPanelConstraints) {\n      if (current.defaultSize === undefined) {\n        layout[current.panelId] = size;\n      }\n    }\n  }\n\n  return layout;\n}\n", "import type { RegisteredGroup } from \"../../components/group/types\";\nimport { calculateAvailableGroupSize } from \"../dom/calculateAvailableGroupSize\";\nimport { formatLayoutNumber } from \"./formatLayoutNumber\";\n\nexport function notifyPanelOnResize(\n  group: RegisteredGroup,\n  element: HTMLElement,\n  borderBoxSize: readonly ResizeObserverSize[]\n) {\n  const resizeObserverSize = borderBoxSize[0];\n  if (!resizeObserverSize) {\n    return;\n  }\n\n  const panel = group.panels.find((current) => current.element === element);\n  if (!panel || !panel.onResize) {\n    return;\n  }\n\n  const groupSize = calculateAvailableGroupSize({ group });\n\n  const prevSize = panel.mutableValues.prevSize;\n  const nextSize = {\n    asPercentage: formatLayoutNumber(\n      (resizeObserverSize.inlineSize / groupSize) * 100\n    ),\n    inPixels: resizeObserverSize.inlineSize\n  };\n  panel.mutableValues.prevSize = nextSize;\n\n  panel.onResize(nextSize, panel.id, prevSize);\n}\n", "export function objectsEqual(a: object, b: object) {\n  const keys = Object.keys(a);\n  if (keys.length !== Object.keys(b).length) {\n    return false;\n  }\n\n  for (const key in a) {\n    if (a[key as keyof typeof a] !== b[key as keyof typeof b]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n", "import type { Layout } from \"../../components/group/types\";\nimport type { RegisteredPanel } from \"../../components/panel/types\";\n\nexport function validateLayoutKeys(panels: RegisteredPanel[], layout: Layout) {\n  const panelIds = panels.map((panel) => panel.id);\n  const layoutKeys = Object.keys(layout);\n\n  if (panelIds.length !== layoutKeys.length) {\n    return false;\n  }\n\n  for (const panelId of panelIds) {\n    if (!layoutKeys.includes(panelId)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n", "import type { Layout, RegisteredGroup } from \"../components/group/types\";\nimport { assert } from \"../utils/assert\";\nimport { calculateAvailableGroupSize } from \"./dom/calculateAvailableGroupSize\";\nimport { calculateHitRegions } from \"./dom/calculateHitRegions\";\nimport { calculatePanelConstraints } from \"./dom/calculatePanelConstraints\";\nimport { onDocumentKeyDown } from \"./event-handlers/onDocumentKeyDown\";\nimport { onDocumentPointerDown } from \"./event-handlers/onDocumentPointerDown\";\nimport { onDocumentPointerLeave } from \"./event-handlers/onDocumentPointerLeave\";\nimport { onDocumentPointerMove } from \"./event-handlers/onDocumentPointerMove\";\nimport { onDocumentPointerUp } from \"./event-handlers/onDocumentPointerUp\";\nimport { update, type SeparatorToPanelsMap } from \"./mutableState\";\nimport { calculateDefaultLayout } from \"./utils/calculateDefaultLayout\";\nimport { layoutsEqual } from \"./utils/layoutsEqual\";\nimport { notifyPanelOnResize } from \"./utils/notifyPanelOnResize\";\nimport { objectsEqual } from \"./utils/objectsEqual\";\nimport { validateLayoutKeys } from \"./utils/validateLayoutKeys\";\nimport { validatePanelGroupLayout } from \"./utils/validatePanelGroupLayout\";\n\nconst ownerDocumentReferenceCounts = new Map<Document, number>();\n\nexport function mountGroup(group: RegisteredGroup) {\n  let isMounted = true;\n\n  assert(\n    group.element.ownerDocument.defaultView,\n    \"Cannot register an unmounted Group\"\n  );\n\n  const ResizeObserver = group.element.ownerDocument.defaultView.ResizeObserver;\n\n  const panelIds = new Set<string>();\n  const separatorIds = new Set<string>();\n\n  // Add Panels with onResize callbacks to ResizeObserver\n  // Add Group to ResizeObserver also in order to sync % based constraints\n  const resizeObserver = new ResizeObserver((entries) => {\n    for (const entry of entries) {\n      const { borderBoxSize, target } = entry;\n      if (target === group.element) {\n        if (isMounted) {\n          const groupSize = calculateAvailableGroupSize({ group });\n          if (groupSize === 0) {\n            // Can't calculate anything meaningful if the group has a width/height of 0\n            // (This could indicate that it's within a hidden subtree)\n            return;\n          }\n\n          update((prevState) => {\n            const match = prevState.mountedGroups.get(group);\n            if (match) {\n              // Update non-percentage based constraints\n              const nextDerivedPanelConstraints =\n                calculatePanelConstraints(group);\n\n              // Revalidate layout in case constraints have changed\n              const prevLayout = match.defaultLayoutDeferred\n                ? calculateDefaultLayout(nextDerivedPanelConstraints)\n                : match.layout;\n              const nextLayout = validatePanelGroupLayout({\n                layout: prevLayout,\n                panelConstraints: nextDerivedPanelConstraints\n              });\n\n              if (\n                !match.defaultLayoutDeferred &&\n                layoutsEqual(prevLayout, nextLayout) &&\n                objectsEqual(\n                  match.derivedPanelConstraints,\n                  nextDerivedPanelConstraints\n                )\n              ) {\n                return prevState;\n              }\n\n              return {\n                mountedGroups: new Map(prevState.mountedGroups).set(group, {\n                  defaultLayoutDeferred: false,\n                  derivedPanelConstraints: nextDerivedPanelConstraints,\n                  layout: nextLayout,\n                  separatorToPanels: match.separatorToPanels\n                })\n              };\n            }\n\n            return prevState;\n          });\n        }\n      } else {\n        notifyPanelOnResize(group, target as HTMLElement, borderBoxSize);\n      }\n    }\n  });\n  resizeObserver.observe(group.element);\n  group.panels.forEach((panel) => {\n    assert(\n      !panelIds.has(panel.id),\n      `Panel ids must be unique; id \"${panel.id}\" was used more than once`\n    );\n\n    panelIds.add(panel.id);\n\n    if (panel.onResize) {\n      resizeObserver.observe(panel.element);\n    }\n  });\n\n  const groupSize = calculateAvailableGroupSize({ group });\n\n  // Calculate initial layout for the new Panel configuration\n  const derivedPanelConstraints = calculatePanelConstraints(group);\n  const panelIdsKey = group.panels.map(({ id }) => id).join(\",\");\n\n  // Gracefully handle an invalid default layout\n  // This could happen when e.g. useDefaultLayout is combined with dynamic Panels\n  // In this case the best we can do is ignore the incoming layout\n  let defaultLayout: Layout | undefined = group.defaultLayout;\n  if (defaultLayout) {\n    if (!validateLayoutKeys(group.panels, defaultLayout)) {\n      defaultLayout = undefined;\n    }\n  }\n\n  const defaultLayoutUnsafe: Layout =\n    group.inMemoryLayouts[panelIdsKey] ??\n    defaultLayout ??\n    calculateDefaultLayout(derivedPanelConstraints);\n  const defaultLayoutSafe = validatePanelGroupLayout({\n    layout: defaultLayoutUnsafe,\n    panelConstraints: derivedPanelConstraints\n  });\n\n  const hitRegions = calculateHitRegions(group);\n\n  const ownerDocument = group.element.ownerDocument;\n\n  update((prevState) => {\n    const separatorToPanels: SeparatorToPanelsMap = new Map();\n\n    ownerDocumentReferenceCounts.set(\n      ownerDocument,\n      (ownerDocumentReferenceCounts.get(ownerDocument) ?? 0) + 1\n    );\n\n    hitRegions.forEach((hitRegion) => {\n      if (hitRegion.separator) {\n        separatorToPanels.set(hitRegion.separator, hitRegion.panels);\n      }\n    });\n\n    return {\n      mountedGroups: new Map(prevState.mountedGroups).set(group, {\n        defaultLayoutDeferred: groupSize === 0,\n        derivedPanelConstraints,\n        layout: defaultLayoutSafe,\n        separatorToPanels\n      })\n    };\n  });\n\n  group.separators.forEach((separator) => {\n    assert(\n      !separatorIds.has(separator.id),\n      `Separator ids must be unique; id \"${separator.id}\" was used more than once`\n    );\n\n    separatorIds.add(separator.id);\n\n    separator.element.addEventListener(\"keydown\", onDocumentKeyDown);\n  });\n\n  // If this is the first group to be mounted, initialize event handlers\n  if (ownerDocumentReferenceCounts.get(ownerDocument) === 1) {\n    ownerDocument.addEventListener(\"pointerdown\", onDocumentPointerDown);\n    ownerDocument.addEventListener(\"pointerleave\", onDocumentPointerLeave);\n    ownerDocument.addEventListener(\"pointermove\", onDocumentPointerMove);\n    ownerDocument.addEventListener(\"pointerup\", onDocumentPointerUp);\n  }\n\n  return function unmountGroup() {\n    isMounted = false;\n\n    ownerDocumentReferenceCounts.set(\n      ownerDocument,\n      Math.max(0, (ownerDocumentReferenceCounts.get(ownerDocument) ?? 0) - 1)\n    );\n\n    update((prevState) => {\n      const mountedGroups = new Map(prevState.mountedGroups);\n      mountedGroups.delete(group);\n\n      return { mountedGroups };\n    });\n\n    group.separators.forEach((separator) => {\n      separator.element.removeEventListener(\"keydown\", onDocumentKeyDown);\n    });\n\n    // If this was the last group to be mounted, tear down event handlers\n    if (!ownerDocumentReferenceCounts.get(ownerDocument)) {\n      ownerDocument.removeEventListener(\"pointerdown\", onDocumentPointerDown);\n      ownerDocument.removeEventListener(\"pointerleave\", onDocumentPointerLeave);\n      ownerDocument.removeEventListener(\"pointermove\", onDocumentPointerMove);\n      ownerDocument.removeEventListener(\"pointerup\", onDocumentPointerUp);\n    }\n\n    resizeObserver.disconnect();\n  };\n}\n", "import { useCallback, useState } from \"react\";\n\nexport function useForceUpdate() {\n  const [sigil, setSigil] = useState({});\n\n  const forceUpdate = useCallback(() => setSigil({}), []);\n\n  return [sigil as unknown, forceUpdate] as const;\n}\n", "import { useId as useIdReact } from \"react\";\n\nexport function useId(stableId: number | string | undefined) {\n  const dynamicId = useIdReact();\n\n  return `${stableId ?? dynamicId}`;\n}\n", "import { useEffect, useLayoutEffect } from \"react\";\n\nexport const useIsomorphicLayoutEffect =\n  typeof window !== \"undefined\" ? useLayoutEffect : useEffect;\n", "import { useCallback, useRef } from \"react\";\nimport { useIsomorphicLayoutEffect } from \"./useIsomorphicLayoutEffect\";\n\n// Forked from useEventCallback (usehooks-ts)\n// eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\nexport function useStableCallback<Callback extends Function>(\n  fn: Callback\n): Callback {\n  const ref = useRef<Callback>(fn);\n\n  useIsomorphicLayoutEffect(() => {\n    ref.current = fn;\n  }, [fn]);\n\n  return useCallback(\n    (...args: unknown[]) => ref.current?.(...args),\n    [ref]\n  ) as unknown as Callback;\n}\n", "import { type Ref } from \"react\";\nimport { useStableCallback } from \"./useStableCallback\";\n\ntype PossibleRef<Type> = Ref<Type> | undefined;\n\nexport function useMergedRefs<Type>(...refs: PossibleRef<Type>[]) {\n  return useStableCallback((value: Type | null) => {\n    refs.forEach((ref) => {\n      if (ref) {\n        switch (typeof ref) {\n          case \"function\": {\n            ref(value);\n            break;\n          }\n          case \"object\": {\n            ref.current = value;\n            break;\n          }\n        }\n      }\n    });\n  });\n}\n", "import { useRef } from \"react\";\nimport { useIsomorphicLayoutEffect } from \"./useIsomorphicLayoutEffect\";\n\nexport function useStableObject<Type extends object>(\n  unstableObject: Type\n): Type {\n  const ref = useRef<Type>({ ...unstableObject });\n\n  useIsomorphicLayoutEffect(() => {\n    for (const key in unstableObject) {\n      ref.current[key] = unstableObject[key];\n    }\n  }, [unstableObject]);\n\n  return ref.current;\n}\n", "export const POINTER_EVENTS_CSS_PROPERTY_NAME =\n  \"--react-resizable-panels--panel--pointer-events\";\n", "export function getPanelSizeCssPropertyName(groupId: string, panelId: string) {\n  const groupIdEscaped = groupId.replace(/[^a-zA-Z0-9\\-_]/g, \"\");\n  const panelIdEscaped = panelId.replace(/[^a-zA-Z0-9\\-_]/g, \"\");\n\n  return `--react-resizable-panels--${groupIdEscaped}--${panelIdEscaped}`;\n}\n", "import { createContext } from \"react\";\nimport type { GroupContextType } from \"./types\";\n\nexport const GroupContext = createContext<GroupContextType | null>(null);\n", "import { useImperativeHandle, useRef, type Ref } from \"react\";\nimport { IDENTITY_FUNCTION } from \"../../constants\";\nimport { getImperativeGroupMethods } from \"../../global/utils/getImperativeGroupMethods\";\nimport { useIsomorphicLayoutEffect } from \"../../hooks/useIsomorphicLayoutEffect\";\nimport type { GroupImperativeHandle } from \"./types\";\n\nexport function useGroupImperativeHandle(\n  groupId: string,\n  groupRef: Ref<GroupImperativeHandle> | undefined\n) {\n  const imperativeGroupRef = useRef<GroupImperativeHandle>({\n    getLayout: () => ({}),\n    setLayout: IDENTITY_FUNCTION\n  });\n\n  useImperativeHandle(groupRef, () => imperativeGroupRef.current, []);\n\n  useIsomorphicLayoutEffect(() => {\n    Object.assign(\n      imperativeGroupRef.current,\n      getImperativeGroupMethods({ groupId })\n    );\n  });\n}\n", "\"use client\";\nimport { useEffect, useMemo, useRef, useState } from \"react\";\nimport { mountGroup } from \"../../global/mountGroup\";\nimport { eventEmitter, read } from \"../../global/mutableState\";\nimport { layoutsEqual } from \"../../global/utils/layoutsEqual\";\nimport { useForceUpdate } from \"../../hooks/useForceUpdate\";\nimport { useId } from \"../../hooks/useId\";\nimport { useIsomorphicLayoutEffect } from \"../../hooks/useIsomorphicLayoutEffect\";\nimport { useMergedRefs } from \"../../hooks/useMergedRefs\";\nimport { useStableCallback } from \"../../hooks/useStableCallback\";\nimport { useStableObject } from \"../../hooks/useStableObject\";\nimport { POINTER_EVENTS_CSS_PROPERTY_NAME } from \"../panel/constants\";\nimport type { RegisteredPanel } from \"../panel/types\";\nimport type { RegisteredSeparator } from \"../separator/types\";\nimport { getPanelSizeCssPropertyName } from \"./getPanelSizeCssPropertyName\";\nimport { GroupContext } from \"./GroupContext\";\nimport { sortByElementOffset } from \"./sortByElementOffset\";\nimport type { GroupProps, Layout, RegisteredGroup } from \"./types\";\nimport { useGroupImperativeHandle } from \"./useGroupImperativeHandle\";\n\n/**\n * A Group wraps a set of resizable Panel components.\n * Group content can be resized _horizontally_ or _vertically_.\n *\n * Group elements always include the following attributes:\n *\n * ```html\n * <div data-group data-testid=\"group-id-prop\" id=\"group-id-prop\">\n * ```\n *\n * â„¹ï¸ [Test id](https://testing-library.com/docs/queries/bytestid/) can be used to narrow selection when unit testing.\n */\nexport function Group({\n  children,\n  className,\n  defaultLayout,\n  disableCursor,\n  disabled,\n  elementRef: elementRefProp,\n  groupRef,\n  id: idProp,\n  onLayoutChange: onLayoutChangeUnstable,\n  orientation = \"horizontal\",\n  style,\n  ...rest\n}: GroupProps) {\n  const prevLayoutRef = useRef<Layout>({});\n\n  const onLayoutChangeStable = useStableCallback((layout: Layout) => {\n    if (layoutsEqual(prevLayoutRef.current, layout)) {\n      // Memoize callback\n      return;\n    }\n\n    prevLayoutRef.current = layout;\n    onLayoutChangeUnstable?.(layout);\n  });\n\n  const id = useId(idProp);\n\n  const elementRef = useRef<HTMLDivElement | null>(null);\n\n  const [dragActive, setDragActive] = useState(false);\n  const [layout, setLayout] = useState(defaultLayout ?? {});\n  const [panelOrSeparatorChangeSigil, forceUpdate] = useForceUpdate();\n\n  const inMemoryValuesRef = useRef<{\n    lastExpandedPanelSizes: { [panelIds: string]: number };\n    layouts: { [panelIds: string]: Layout };\n    panels: RegisteredPanel[];\n    separators: RegisteredSeparator[];\n  }>({\n    lastExpandedPanelSizes: {},\n    layouts: {},\n    panels: [],\n    separators: []\n  });\n\n  const mergedRef = useMergedRefs(elementRef, elementRefProp);\n\n  useGroupImperativeHandle(id, groupRef);\n\n  const context = useMemo(\n    () => ({\n      id,\n      orientation,\n      registerPanel: (panel: RegisteredPanel) => {\n        const inMemoryValues = inMemoryValuesRef.current;\n        inMemoryValues.panels = sortByElementOffset(orientation, [\n          ...inMemoryValues.panels,\n          panel\n        ]);\n\n        forceUpdate();\n\n        return () => {\n          inMemoryValues.panels = inMemoryValues.panels.filter(\n            (current) => current !== panel\n          );\n\n          forceUpdate();\n        };\n      },\n      registerSeparator: (separator: RegisteredSeparator) => {\n        const inMemoryValues = inMemoryValuesRef.current;\n        inMemoryValues.separators = sortByElementOffset(orientation, [\n          ...inMemoryValues.separators,\n          separator\n        ]);\n\n        forceUpdate();\n\n        return () => {\n          inMemoryValues.separators = inMemoryValues.separators.filter(\n            (current) => current !== separator\n          );\n\n          forceUpdate();\n        };\n      }\n    }),\n    [id, forceUpdate, orientation]\n  );\n\n  const stableProps = useStableObject({\n    defaultLayout,\n    disableCursor\n  });\n\n  const registeredGroupRef = useRef<RegisteredGroup | null>(null);\n\n  // Register Group and child Panels/Separators with global state\n  // Listen to global state for drag state related to this Group\n  useIsomorphicLayoutEffect(() => {\n    const element = elementRef.current;\n    if (element === null) {\n      return;\n    }\n\n    const inMemoryValues = inMemoryValuesRef.current;\n\n    const group: RegisteredGroup = {\n      defaultLayout: stableProps.defaultLayout,\n      disableCursor: !!stableProps.disableCursor,\n      disabled: !!disabled,\n      element,\n      id,\n      inMemoryLastExpandedPanelSizes:\n        inMemoryValuesRef.current.lastExpandedPanelSizes,\n      inMemoryLayouts: inMemoryValuesRef.current.layouts,\n      orientation,\n      panels: inMemoryValues.panels,\n      separators: inMemoryValues.separators\n    };\n\n    registeredGroupRef.current = group;\n\n    const unmountGroup = mountGroup(group);\n\n    const globalState = read();\n    const match = globalState.mountedGroups.get(group);\n    if (match) {\n      const { defaultLayoutDeferred, derivedPanelConstraints, layout } = match;\n\n      if (!defaultLayoutDeferred && derivedPanelConstraints.length > 0) {\n        setLayout(layout);\n\n        onLayoutChangeStable?.(layout);\n      }\n    }\n\n    const removeInteractionStateChangeListener = eventEmitter.addListener(\n      \"interactionStateChange\",\n      (interactionState) => {\n        switch (interactionState.state) {\n          case \"active\": {\n            setDragActive(\n              interactionState.hitRegions.some(\n                (current) => current.group === group\n              )\n            );\n            break;\n          }\n          default: {\n            setDragActive(false);\n            break;\n          }\n        }\n      }\n    );\n\n    const removeMountedGroupsChangeEventListener = eventEmitter.addListener(\n      \"mountedGroupsChange\",\n      (mountedGroups) => {\n        const match = mountedGroups.get(group);\n        if (match) {\n          const { defaultLayoutDeferred, derivedPanelConstraints, layout } =\n            match;\n\n          if (defaultLayoutDeferred || derivedPanelConstraints.length === 0) {\n            // This indicates that the Group has not finished mounting yet\n            // Likely because it has been rendered inside of a hidden DOM subtree\n            // Ignore layouts in this case because they will not have been validated\n            return;\n          }\n\n          setLayout(layout);\n\n          onLayoutChangeStable?.(layout);\n        }\n      }\n    );\n\n    return () => {\n      registeredGroupRef.current = null;\n\n      unmountGroup();\n      removeInteractionStateChangeListener();\n      removeMountedGroupsChangeEventListener();\n    };\n  }, [\n    disabled,\n    id,\n    onLayoutChangeStable,\n    orientation,\n    panelOrSeparatorChangeSigil,\n    stableProps\n  ]);\n\n  // Not all props require re-registering the group;\n  // Some can be updated after the group has been registered\n  useEffect(() => {\n    const registeredGroup = registeredGroupRef.current;\n    if (registeredGroup) {\n      registeredGroup.defaultLayout = defaultLayout;\n      registeredGroup.disableCursor = !!disableCursor;\n    }\n  });\n\n  // Panel layouts and Group dragging state are shared via CSS variables\n  const cssVariables: { [key: string]: number | string | undefined } = {\n    [POINTER_EVENTS_CSS_PROPERTY_NAME]: dragActive ? \"none\" : undefined\n  };\n  for (const panelId in layout) {\n    const propertyName = getPanelSizeCssPropertyName(id, panelId);\n    const flexGrow = layout[panelId];\n    cssVariables[propertyName] = flexGrow;\n  }\n\n  return (\n    <GroupContext.Provider value={context}>\n      <div\n        {...rest}\n        aria-orientation={orientation}\n        className={className}\n        data-group\n        data-testid={id}\n        id={id}\n        ref={mergedRef}\n        style={{\n          ...style,\n          ...cssVariables,\n          display: \"flex\",\n          flexDirection: orientation === \"horizontal\" ? \"row\" : \"column\",\n          flexWrap: \"nowrap\"\n        }}\n      >\n        {children}\n      </div>\n    </GroupContext.Provider>\n  );\n}\n\n// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/displayName\nGroup.displayName = \"Group\";\n", "export function debounce(fn: () => void, durationMs?: number): () => void;\nexport function debounce<Args>(\n  fn: (args: Args) => void,\n  durationMs?: number\n): (args: Args) => void;\nexport function debounce<Args>(\n  fn: (args: Args) => void,\n  durationMs: number = 10\n): (args: Args) => void {\n  let timeout: NodeJS.Timeout | null = null;\n\n  return (args: Args) => {\n    if (timeout !== null) {\n      clearTimeout(timeout);\n    }\n\n    timeout = setTimeout(() => {\n      fn(args);\n    }, durationMs);\n  };\n}\n", "export function getStorageKey(id: string, panelIds: string[]): string {\n  return `react-resizable-panels:${[id, ...panelIds].join(\":\")}`;\n}\n", "import { useMemo, useSyncExternalStore } from \"react\";\nimport { debounce } from \"../../utils/debounce\";\nimport { getStorageKey } from \"./auto-save/getStorageKey\";\nimport type { Layout, LayoutStorage, OnGroupLayoutChange } from \"./types\";\n\n/**\n * Saves and restores group layouts between page loads.\n * It can be configured to store values using `localStorage`, `sessionStorage`, cookies, or any other persistence layer that makes sense for your application.\n */\nexport function useDefaultLayout({\n  debounceSaveMs = 100,\n  panelIds,\n  storage = localStorage,\n  ...rest\n}: {\n  /**\n   * Debounce save operation by the specified number of milliseconds; defaults to 100ms\n   */\n  debounceSaveMs?: number;\n\n  /**\n   * For Groups that contain conditionally-rendered Panels, this prop can be used to save and restore multiple layouts.\n   *\n   * â„¹ï¸ This prevents layout shift for server-rendered apps.\n   *\n   * âš ï¸ Panel ids must match the Panels rendered within the Group during mount or the initial layout will be incorrect.\n   */\n  panelIds?: string[] | undefined;\n\n  /**\n   * Storage implementation; supports localStorage, sessionStorage, and custom implementations\n   * Refer to documentation site for example integrations.\n   *\n   */\n  storage?: LayoutStorage;\n} & (\n  | {\n      /**\n       * Group id; must be unique in order for layouts to be saved separately.\n       * @deprecated Use the {@link id} param instead\n       */\n      groupId: string;\n    }\n  | {\n      /**\n       * Uniquely identifies a specific group/layout.\n       */\n      id: string;\n    }\n)) {\n  const hasPanelIds = panelIds !== undefined;\n  const id = \"id\" in rest ? rest.id : rest.groupId;\n\n  const readStorageKey = getStorageKey(id, panelIds ?? []);\n\n  // In the event that a client-only storage API is provided,\n  // useSyncExternalStore prevents server/client hydration mismatch warning\n  // This is not ideal; if possible a server-friendly storage API should be used\n  const defaultLayoutString = useSyncExternalStore(\n    subscribe,\n    () => storage.getItem(readStorageKey),\n    () => storage.getItem(readStorageKey)\n  );\n\n  const defaultLayout = useMemo(\n    () =>\n      defaultLayoutString\n        ? (JSON.parse(defaultLayoutString) as Layout)\n        : undefined,\n    [defaultLayoutString]\n  );\n\n  const onLayoutChange = useMemo<NonNullable<OnGroupLayoutChange>>(() => {\n    const saveLayout = (layout: Layout) => {\n      let writeStorageKey: string;\n      if (hasPanelIds) {\n        writeStorageKey = getStorageKey(id, Object.keys(layout));\n      } else {\n        writeStorageKey = getStorageKey(id, []);\n      }\n\n      try {\n        storage.setItem(writeStorageKey, JSON.stringify(layout));\n      } catch (error) {\n        console.error(error);\n      }\n    };\n\n    return debounceSaveMs > 0\n      ? debounce(saveLayout, debounceSaveMs)\n      : saveLayout;\n  }, [debounceSaveMs, hasPanelIds, id, storage]);\n\n  return {\n    defaultLayout,\n    onLayoutChange\n  };\n}\n\nfunction subscribe() {\n  return function unsubscribe() {};\n}\n", "import { useState } from \"react\";\nimport type { GroupImperativeHandle } from \"./types\";\n\n/**\n * Convenience hook to return a properly typed ref callback for the Group component.\n *\n * Use this hook when you need to share the ref with another component or hook.\n */\nexport function useGroupCallbackRef() {\n  return useState<GroupImperativeHandle | null>(null);\n}\n", "import { useRef } from \"react\";\nimport type { GroupImperativeHandle } from \"./types\";\n\n/**\n * Convenience hook to return a properly typed ref for the Group component.\n */\nexport function useGroupRef() {\n  return useRef<GroupImperativeHandle>(null);\n}\n", "import { useContext } from \"react\";\nimport { assert } from \"../../utils/assert\";\nimport { GroupContext } from \"./GroupContext\";\n\nexport function useGroupContext() {\n  const context = useContext(GroupContext);\n  assert(\n    context,\n    \"Group Context not found; did you render a Panel or Separator outside of a Group?\"\n  );\n\n  return context;\n}\n", "import type { PanelImperativeHandle } from \"../../components/panel/types\";\nimport { calculateAvailableGroupSize } from \"../dom/calculateAvailableGroupSize\";\nimport { read, update } from \"../mutableState\";\nimport { adjustLayoutByDelta } from \"./adjustLayoutByDelta\";\nimport { formatLayoutNumber } from \"./formatLayoutNumber\";\nimport { layoutNumbersEqual } from \"./layoutNumbersEqual\";\nimport { layoutsEqual } from \"./layoutsEqual\";\nimport { validatePanelGroupLayout } from \"./validatePanelGroupLayout\";\n\nexport function getImperativePanelMethods({\n  groupId,\n  panelId\n}: {\n  groupId: string;\n  panelId: string;\n}): PanelImperativeHandle {\n  const find = () => {\n    const { mountedGroups } = read();\n    for (const [\n      group,\n      {\n        defaultLayoutDeferred,\n        derivedPanelConstraints,\n        layout,\n        separatorToPanels\n      }\n    ] of mountedGroups) {\n      if (group.id === groupId) {\n        return {\n          defaultLayoutDeferred,\n          derivedPanelConstraints,\n          group,\n          layout,\n          separatorToPanels\n        };\n      }\n    }\n\n    throw Error(`Group ${groupId} not found`);\n  };\n\n  const getPanelConstraints = () => {\n    const match = find().derivedPanelConstraints.find(\n      (current) => current.panelId === panelId\n    );\n    if (match !== undefined) {\n      return match;\n    }\n\n    throw Error(`Panel constraints not found for Panel ${panelId}`);\n  };\n\n  const getPanel = () => {\n    const match = find().group.panels.find((current) => current.id === panelId);\n    if (match !== undefined) {\n      return match;\n    }\n\n    throw Error(`Layout not found for Panel ${panelId}`);\n  };\n\n  const getPanelSize = () => {\n    const match = find().layout[panelId];\n    if (match !== undefined) {\n      return match;\n    }\n\n    throw Error(`Layout not found for Panel ${panelId}`);\n  };\n\n  const setPanelSize = (nextSize: number) => {\n    const prevSize = getPanelSize();\n    if (nextSize === prevSize) {\n      return;\n    }\n\n    const {\n      defaultLayoutDeferred,\n      derivedPanelConstraints,\n      group,\n      layout: prevLayout,\n      separatorToPanels\n    } = find();\n\n    const index = group.panels.findIndex((current) => current.id === panelId);\n    const isLastPanel = index === group.panels.length - 1;\n\n    const unsafeLayout = adjustLayoutByDelta({\n      delta: isLastPanel ? prevSize - nextSize : nextSize - prevSize,\n      initialLayout: prevLayout,\n      panelConstraints: derivedPanelConstraints,\n      pivotIndices: isLastPanel ? [index - 1, index] : [index, index + 1],\n      prevLayout,\n      trigger: \"imperative-api\"\n    });\n\n    const nextLayout = validatePanelGroupLayout({\n      layout: unsafeLayout,\n      panelConstraints: derivedPanelConstraints\n    });\n    if (!layoutsEqual(prevLayout, nextLayout)) {\n      update((prevState) => ({\n        mountedGroups: new Map(prevState.mountedGroups).set(group, {\n          defaultLayoutDeferred,\n          derivedPanelConstraints,\n          layout: nextLayout,\n          separatorToPanels\n        })\n      }));\n    }\n  };\n\n  return {\n    collapse: () => {\n      const { collapsible, collapsedSize } = getPanelConstraints();\n      const { mutableValues } = getPanel();\n      const size = getPanelSize();\n\n      if (collapsible && size !== collapsedSize) {\n        // Store previous size in to restore if expand() is called\n        mutableValues.expandToSize = size;\n\n        setPanelSize(collapsedSize);\n      }\n    },\n    expand: () => {\n      const { collapsible, collapsedSize, minSize } = getPanelConstraints();\n      const { mutableValues } = getPanel();\n      const size = getPanelSize();\n\n      if (collapsible && size === collapsedSize) {\n        // Restore pre-collapse size, fallback to minSize\n        let nextSize = mutableValues.expandToSize ?? minSize;\n\n        // Edge case: if minSize is 0, pick something meaningful to expand the panel to\n        if (nextSize === 0) {\n          nextSize = 1;\n        }\n\n        setPanelSize(nextSize);\n      }\n    },\n    getSize: () => {\n      const { group } = find();\n      const asPercentage = getPanelSize();\n      const { element } = getPanel();\n\n      const inPixels =\n        group.orientation === \"horizontal\"\n          ? element.offsetWidth\n          : element.offsetHeight;\n\n      return {\n        asPercentage,\n        inPixels\n      };\n    },\n    isCollapsed: () => {\n      const { collapsible, collapsedSize } = getPanelConstraints();\n      const size = getPanelSize();\n\n      return collapsible && layoutNumbersEqual(collapsedSize, size);\n    },\n    resize: (size: number | string) => {\n      const prevSize = getPanelSize();\n      if (prevSize !== size) {\n        let asPercentage;\n        switch (typeof size) {\n          case \"number\": {\n            const { group } = find();\n            const groupSize = calculateAvailableGroupSize({ group });\n            asPercentage = formatLayoutNumber((size / groupSize) * 100);\n            break;\n          }\n          case \"string\": {\n            asPercentage = parseFloat(size);\n            break;\n          }\n        }\n\n        setPanelSize(asPercentage);\n      }\n    }\n  } satisfies PanelImperativeHandle;\n}\n", "import { useImperativeHandle, useRef, type Ref } from \"react\";\nimport { NOOP_FUNCTION } from \"../../constants\";\nimport { getImperativePanelMethods } from \"../../global/utils/getImperativePanelMethods\";\nimport { useIsomorphicLayoutEffect } from \"../../hooks/useIsomorphicLayoutEffect\";\nimport { useGroupContext } from \"../group/useGroupContext\";\nimport type { PanelImperativeHandle } from \"./types\";\n\nexport function usePanelImperativeHandle(\n  panelId: string,\n  panelRef: Ref<PanelImperativeHandle> | undefined\n) {\n  const { id: groupId } = useGroupContext();\n\n  const imperativePanelRef = useRef<PanelImperativeHandle>({\n    collapse: NOOP_FUNCTION,\n    expand: NOOP_FUNCTION,\n    getSize: () => ({\n      asPercentage: 0,\n      inPixels: 0\n    }),\n    isCollapsed: () => false,\n    resize: NOOP_FUNCTION\n  });\n\n  useImperativeHandle(panelRef, () => imperativePanelRef.current, []);\n\n  useIsomorphicLayoutEffect(() => {\n    Object.assign(\n      imperativePanelRef.current,\n      getImperativePanelMethods({ groupId, panelId })\n    );\n  });\n}\n", "\"use client\";\n\nimport type { Property } from \"csstype\";\nimport { useRef, type CSSProperties } from \"react\";\nimport { useId } from \"../../hooks/useId\";\nimport { useIsomorphicLayoutEffect } from \"../../hooks/useIsomorphicLayoutEffect\";\nimport { useMergedRefs } from \"../../hooks/useMergedRefs\";\nimport { useStableCallback } from \"../../hooks/useStableCallback\";\nimport { getPanelSizeCssPropertyName } from \"../group/getPanelSizeCssPropertyName\";\nimport { useGroupContext } from \"../group/useGroupContext\";\nimport { POINTER_EVENTS_CSS_PROPERTY_NAME } from \"./constants\";\nimport type { PanelProps, PanelSize } from \"./types\";\nimport { usePanelImperativeHandle } from \"./usePanelImperativeHandle\";\n\n/**\n * A Panel wraps resizable content and can be configured with min/max size constraints and collapsible behavior.\n *\n * Panel size props can be in the following formats:\n * - Percentage of the parent Group (0..100)\n * - Pixels\n * - Relative font units (em, rem)\n * - Viewport relative units (vh, vw)\n *\n * â„¹ï¸ Numeric values are assumed to be pixels.\n * Strings without explicit units are assumed to be percentages (0%..100%).\n * Percentages may also be specified as strings ending with \"%\" (e.g. \"33%\")\n * Pixels may also be specified as strings ending with the unit \"px\".\n * Other units should be specified as strings ending with their CSS property units (e.g. 1rem, 50vh)\n *\n * Panel elements always include the following attributes:\n *\n * ```html\n * <div data-panel data-testid=\"panel-id-prop\" id=\"panel-id-prop\">\n * ```\n *\n * â„¹ï¸ [Test id](https://testing-library.com/docs/queries/bytestid/) can be used to narrow selection when unit testing.\n */\nexport function Panel({\n  children,\n  className,\n  collapsedSize = \"0%\",\n  collapsible = false,\n  defaultSize,\n  elementRef: elementRefProp,\n  id: idProp,\n  maxSize = \"100%\",\n  minSize = \"0%\",\n  onResize: onResizeUnstable,\n  panelRef,\n  style,\n  ...rest\n}: PanelProps) {\n  const idIsStable = !!idProp;\n\n  const id = useId(idProp);\n\n  const elementRef = useRef<HTMLDivElement | null>(null);\n\n  const mergedRef = useMergedRefs(elementRef, elementRefProp);\n\n  const { id: groupId, registerPanel } = useGroupContext();\n\n  const hasOnResize = onResizeUnstable !== null;\n  const onResizeStable = useStableCallback(\n    (\n      panelSize: PanelSize,\n      _: string | number | undefined,\n      prevPanelSize: PanelSize | undefined\n    ) => {\n      onResizeUnstable?.(panelSize, idProp, prevPanelSize);\n    }\n  );\n\n  // Register Panel with parent Group\n  useIsomorphicLayoutEffect(() => {\n    const element = elementRef.current;\n    if (element !== null) {\n      return registerPanel({\n        element,\n        id,\n        idIsStable,\n        mutableValues: {\n          expandToSize: undefined,\n          prevSize: undefined\n        },\n        onResize: hasOnResize ? onResizeStable : undefined,\n        panelConstraints: {\n          collapsedSize,\n          collapsible,\n          defaultSize,\n          maxSize,\n          minSize\n        }\n      });\n    }\n  }, [\n    collapsedSize,\n    collapsible,\n    defaultSize,\n    hasOnResize,\n    id,\n    idIsStable,\n    maxSize,\n    minSize,\n    onResizeStable,\n    registerPanel\n  ]);\n\n  usePanelImperativeHandle(id, panelRef);\n\n  const flexGrowVar = getPanelSizeCssPropertyName(groupId, id);\n\n  return (\n    <div\n      {...rest}\n      data-panel\n      data-testid={id}\n      id={id}\n      ref={mergedRef}\n      style={{\n        ...PROHIBITED_CSS_PROPERTIES,\n\n        flexBasis: 0,\n        flexGrow: `var(${flexGrowVar}, 1)`,\n        flexShrink: 1,\n\n        // Prevent Panel content from interfering with panel size\n        overflow: \"hidden\",\n\n        // Disable pointer events inside of a panel during resize\n        // This avoid edge cases like nested iframes\n        pointerEvents:\n          `var(${POINTER_EVENTS_CSS_PROPERTY_NAME})` as Property.PointerEvents\n      }}\n    >\n      <div\n        className={className}\n        style={{\n          width: \"100%\",\n          height: \"100%\",\n          ...style\n        }}\n      >\n        {children}\n      </div>\n    </div>\n  );\n}\n\n// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/displayName\nPanel.displayName = \"Panel\";\n\nconst PROHIBITED_CSS_PROPERTIES: CSSProperties = {\n  minHeight: \"unset\",\n  maxHeight: \"unset\",\n  height: \"unset\",\n\n  minWidth: \"unset\",\n  maxWidth: \"unset\",\n  width: \"unset\",\n\n  flex: \"unset\",\n  flexBasis: \"unset\",\n  flexShrink: \"unset\",\n  flexGrow: \"unset\",\n\n  border: \"unset\",\n  borderWidth: \"unset\",\n  padding: \"unset\",\n  margin: \"unset\"\n};\n", "import { useState } from \"react\";\nimport type { PanelImperativeHandle } from \"./types\";\n\n/**\n * Convenience hook to return a properly typed ref callback for the Panel component.\n *\n * Use this hook when you need to share the ref with another component or hook.\n */\nexport function usePanelCallbackRef() {\n  return useState<PanelImperativeHandle | null>(null);\n}\n", "import { useRef } from \"react\";\nimport type { PanelImperativeHandle } from \"./types\";\n\n/**\n * Convenience hook to return a properly typed ref for the Panel component.\n */\nexport function usePanelRef() {\n  return useRef<PanelImperativeHandle>(null);\n}\n", "import type { Layout } from \"../../components/group/types\";\nimport type { PanelConstraints } from \"../../components/panel/types\";\nimport { adjustLayoutByDelta } from \"./adjustLayoutByDelta\";\nimport { validatePanelGroupLayout } from \"./validatePanelGroupLayout\";\n\nexport function calculateSeparatorAriaValues({\n  layout,\n  panelConstraints,\n  panelId,\n  panelIndex\n}: {\n  layout: Layout;\n  panelConstraints: PanelConstraints[];\n  panelId: string;\n  panelIndex: number;\n}): {\n  valueControls: string | undefined;\n  valueMax: number | undefined;\n  valueMin: number | undefined;\n  valueNow: number | undefined;\n} {\n  let valueMax: number | undefined = undefined;\n  let valueMin: number | undefined = undefined;\n\n  const panelSize = layout[panelId];\n\n  const constraints = panelConstraints.find(\n    (current) => current.panelId === panelId\n  );\n  if (constraints) {\n    const maxSize = constraints.maxSize;\n    const minSize = (valueMin = constraints.collapsible\n      ? constraints.collapsedSize\n      : constraints.minSize);\n\n    const pivotIndices = [panelIndex, panelIndex + 1];\n\n    const minSizeLayout = validatePanelGroupLayout({\n      layout: adjustLayoutByDelta({\n        delta: minSize - panelSize,\n        initialLayout: layout,\n        panelConstraints,\n        pivotIndices,\n        prevLayout: layout,\n        trigger: \"keyboard\"\n      }),\n      panelConstraints\n    });\n\n    valueMin = minSizeLayout[panelId];\n\n    const maxSizeLayout = validatePanelGroupLayout({\n      layout: adjustLayoutByDelta({\n        delta: maxSize - panelSize,\n        initialLayout: layout,\n        panelConstraints,\n        pivotIndices,\n        prevLayout: layout,\n        trigger: \"keyboard\"\n      }),\n      panelConstraints\n    });\n\n    valueMax = maxSizeLayout[panelId];\n  }\n\n  return {\n    valueControls: panelId,\n    valueMax,\n    valueMin,\n    valueNow: panelSize\n  };\n}\n", "\"use client\";\n\nimport { useRef, useState } from \"react\";\nimport { eventEmitter } from \"../../global/mutableState\";\nimport type { InteractionState } from \"../../global/types\";\nimport { calculateSeparatorAriaValues } from \"../../global/utils/calculateSeparatorAriaValues\";\nimport { useId } from \"../../hooks/useId\";\nimport { useIsomorphicLayoutEffect } from \"../../hooks/useIsomorphicLayoutEffect\";\nimport { useMergedRefs } from \"../../hooks/useMergedRefs\";\nimport { useGroupContext } from \"../group/useGroupContext\";\nimport type { RegisteredSeparator, SeparatorProps } from \"./types\";\n\n/**\n * Separators are not _required_ but they are _recommended_ as they improve keyboard accessibility.\n *\n * Separators should be rendered as the direct child of a Group component.\n *\n * Separator elements always include the following attributes:\n *\n * ```html\n * <div data-separator data-testid=\"separator-id-prop\" id=\"separator-id-prop\" role=\"separator\">\n * ```\n *\n * â„¹ï¸ [Test id](https://testing-library.com/docs/queries/bytestid/) can be used to narrow selection when unit testing.\n *\n * â„¹ï¸ In addition to the attributes shown above, separator also renders all required [WAI-ARIA properties](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Reference/Roles/separator_role#associated_wai-aria_roles_states_and_properties).\n */\nexport function Separator({\n  children,\n  className,\n  elementRef: elementRefProp,\n  id: idProp,\n  style,\n  ...rest\n}: SeparatorProps) {\n  const id = useId(idProp);\n\n  const [aria, setAria] = useState<{\n    valueControls?: string | undefined;\n    valueMin?: number | undefined;\n    valueMax?: number | undefined;\n    valueNow?: number | undefined;\n  }>({});\n\n  const [dragState, setDragState] =\n    useState<InteractionState[\"state\"]>(\"inactive\");\n\n  const elementRef = useRef<HTMLDivElement | null>(null);\n\n  const mergedRef = useMergedRefs(elementRef, elementRefProp);\n\n  const {\n    id: groupId,\n    orientation: groupOrientation,\n    registerSeparator\n  } = useGroupContext();\n\n  const orientation =\n    groupOrientation === \"horizontal\" ? \"vertical\" : \"horizontal\";\n\n  // Register Separator with parent Group\n  // Listen to global state for drag state related to this Separator\n  useIsomorphicLayoutEffect(() => {\n    const element = elementRef.current;\n    if (element !== null) {\n      const separator: RegisteredSeparator = {\n        element,\n        id\n      };\n\n      const unregisterSeparator = registerSeparator(separator);\n\n      const removeInteractionStateChangeListener = eventEmitter.addListener(\n        \"interactionStateChange\",\n        (interactionState) => {\n          setDragState(\n            interactionState.state !== \"inactive\" &&\n              interactionState.hitRegions.some(\n                (hitRegion) => hitRegion.separator === separator\n              )\n              ? interactionState.state\n              : \"inactive\"\n          );\n        }\n      );\n\n      const removeMountedGroupsChangeListener = eventEmitter.addListener(\n        \"mountedGroupsChange\",\n        (mountedGroups) => {\n          mountedGroups.forEach(\n            (\n              { derivedPanelConstraints, layout, separatorToPanels },\n              mountedGroup\n            ) => {\n              if (mountedGroup.id === groupId) {\n                const panels = separatorToPanels.get(separator);\n                if (panels) {\n                  const primaryPanel = panels[0];\n                  const panelIndex = mountedGroup.panels.indexOf(primaryPanel);\n\n                  setAria(\n                    calculateSeparatorAriaValues({\n                      layout,\n                      panelConstraints: derivedPanelConstraints,\n                      panelId: primaryPanel.id,\n                      panelIndex\n                    })\n                  );\n                }\n              }\n            }\n          );\n        }\n      );\n\n      return () => {\n        removeInteractionStateChangeListener();\n        removeMountedGroupsChangeListener();\n        unregisterSeparator();\n      };\n    }\n  }, [groupId, id, registerSeparator]);\n\n  return (\n    <div\n      {...rest}\n      aria-controls={aria.valueControls}\n      aria-orientation={orientation}\n      aria-valuemax={aria.valueMax}\n      aria-valuemin={aria.valueMin}\n      aria-valuenow={aria.valueNow}\n      children={children}\n      className={className}\n      data-separator={dragState}\n      data-testid={id}\n      id={id}\n      ref={mergedRef}\n      role=\"separator\"\n      style={{\n        flexBasis: \"auto\",\n        ...style,\n        flexGrow: 0,\n        flexShrink: 0\n      }}\n      tabIndex={0}\n    />\n  );\n}\n\n// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/displayName\nSeparator.displayName = \"Separator\";\n"],
  "mappings": ";;;;;;;;;;;;;;AAAO,SAASA,EACdC,GACAC,IAAkB,mBACS;AAC3B,MAAI,CAACD;AACH,UAAM,MAAMC,CAAO;AAEvB;ACLO,SAASC,EAA4B;EAC1C,OAAAC;AACF,GAEG;AACD,QAAM,EAAE,aAAAC,GAAa,QAAAC,EAAA,IAAWF;AAEhC,SAAOE,EAAO,OAAO,CAACC,GAAWC,OAC/BD,KACEF,MAAgB,eACZG,EAAM,QAAQ,cACdA,EAAM,QAAQ,cACbD,IACN,CAAC;AACN;ACdO,SAASE,GAGdJ,GAA0BK,GAAwC;AAClE,SAAOA,EAAmB;IACxBL,MAAgB,eAAeM,KAAiBC;EAAA;AAEpD;AAEA,SAASD,GACPE,GACAC,GACA;AACA,QAAMC,IAAQF,EAAE,QAAQ,aAAaC,EAAE,QAAQ;AAC/C,SAAIC,MAAU,IACLA,IAEFF,EAAE,QAAQ,cAAcC,EAAE,QAAQ;AAC3C;AAEA,SAASF,GAAoDC,GAASC,GAAS;AAC7E,QAAMC,IAAQF,EAAE,QAAQ,YAAYC,EAAE,QAAQ;AAC9C,SAAIC,MAAU,IACLA,IAEFF,EAAE,QAAQ,eAAeC,EAAE,QAAQ;AAC5C;AC3BO,SAASE,GAAcC,GAAsC;AAClE,SACEA,MAAU,QACV,OAAOA,KAAU,YACjB,cAAcA,KACdA,EAAM,aAAa,KAAK;AAE5B;ACNO,SAASC,GACdC,GACAC,GACA;AACA,SAAO;IACL,GACED,EAAM,KAAKC,EAAK,QAAQD,EAAM,KAAKC,EAAK,QACpC,IACA,KAAK;MACH,KAAK,IAAID,EAAM,IAAIC,EAAK,IAAI;MAC5B,KAAK,IAAID,EAAM,IAAIC,EAAK,KAAK;IAAA;IAErC,GACED,EAAM,KAAKC,EAAK,OAAOD,EAAM,KAAKC,EAAK,SACnC,IACA,KAAK;MACH,KAAK,IAAID,EAAM,IAAIC,EAAK,GAAG;MAC3B,KAAK,IAAID,EAAM,IAAIC,EAAK,MAAM;IAAA;EAChC;AAEV;AClBO,SAASC,GAAgB;EAC9B,aAAAhB;EACA,OAAAiB;EACA,YAAAC;AACF,GAIoB;AAClB,QAAMC,IAAc;IAClB,GAAGD,EAAW,IAAIA,EAAW,QAAQ;IACrC,GAAGA,EAAW,IAAIA,EAAW,SAAS;EAAA;AAGxC,MAAIE,GACAC,IAAc,OAAO;AAEzB,aAAWN,KAAQE,GAAO;AACxB,UAAM,EAAE,GAAAK,GAAG,GAAAC,EAAA,IAAMV,GAA+BM,GAAaJ,CAAI,GAE3DS,IAAWxB,MAAgB,eAAesB,IAAIC;AAEhDC,QAAWH,MACbA,IAAcG,GACdJ,IAAcL;EAElB;AAEA,SAAApB,EAAOyB,GAAa,eAAe,GAE5BA;AACT;ACVO,SAASK,GAAoB1B,GAAwB;AAC1D,QAAM,EAAE,SAAS2B,GAAc,aAAA1B,GAAa,QAAAC,GAAQ,YAAA0B,EAAAA,IAAe5B,GAG7D6B,IAAqCxB;IACzCJ;IACA,MAAM,KAAK0B,EAAa,QAAQ,EAC7B,OAAOf,EAAa,EACpB,IAAI,CAACkB,OAAa,EAAE,SAAAA,EAAAA,EAAkC;EAAA,EACzD,IAAI,CAAC,EAAE,SAAAA,EAAA,MAAcA,CAAO,GAExBC,IAA0B,CAAA;AAEhC,MAAIC,IAA8B,OAC9BC,GACAC,IAA2C,CAAA;AAE/C,aAAWC,KAAgBN;AACzB,QAAIM,EAAa,aAAa,YAAY,GAAG;AAC3C,YAAMC,IAAYlC,EAAO;QACvB,CAACmC,MAAYA,EAAQ,YAAYF;MAAA;AAEnC,UAAIC,GAAW;AACb,YAAIH,GAAW;AACb,gBAAMK,IAAWL,EAAU,QAAQ,sBAAA,GAC7BjB,IAAOmB,EAAa,sBAAA;AAE1B,cAAII;AAMJ,cAAIP,GAA6B;AAC/B,kBAAMQ,IACJvC,MAAgB,eACZ,IAAI,QAAQqC,EAAS,OAAOA,EAAS,KAAK,GAAGA,EAAS,MAAM,IAC5D,IAAI;cACFA,EAAS;cACTA,EAAS;cACTA,EAAS;cACT;YAAA,GAEFG,IACJxC,MAAgB,eACZ,IAAI,QAAQe,EAAK,MAAMA,EAAK,KAAK,GAAGA,EAAK,MAAM,IAC/C,IAAI,QAAQA,EAAK,MAAMA,EAAK,KAAKA,EAAK,OAAO,CAAC;AAEpD,oBAAQkB,EAAkB,QAAA;cACxB,KAAK,GAAG;AACNK,oBAA2B;kBACzBC;kBACAC;gBAAA;AAEF;cACF;cACA,KAAK,GAAG;AACN,sBAAMC,IAAYR,EAAkB,CAAC,GAC/Bb,IAAcJ,GAAgB;kBAClC,aAAAhB;kBACA,OAAO,CAACqC,GAAUtB,CAAI;kBACtB,YAAY0B,EAAU,QAAQ,sBAAA;gBAAsB,CACrD;AAEDH,oBAA2B;kBACzBG;kBACArB,MAAgBiB,IACZG,IACAD;gBAAA;AAEN;cACF;cACA,SAAS;AACPD,oBAA2BL;AAC3B;cACF;YAAA;UAEJ;AACMA,cAAkB,SACpBK,IAA2BL,IAE3BK,IAA2B;cACzBtC,MAAgB,eACZ,IAAI;gBACFqC,EAAS;gBACTtB,EAAK;gBACLA,EAAK,OAAOsB,EAAS;gBACrBtB,EAAK;cAAA,IAEP,IAAI;gBACFA,EAAK;gBACLsB,EAAS;gBACTtB,EAAK;gBACLA,EAAK,MAAMsB,EAAS;cAAA;YACtB;AAKV,qBAAWK,KAAmBJ;AAC5BR,cAAW,KAAK;cACd,OAAA/B;cACA,WAAWD,EAA4B,EAAE,OAAAC,EAAAA,CAAO;cAChD,QAAQ,CAACiC,GAAWG,CAAS;cAC7B,WACE,WAAWO,IAAkB,SAAYA;cAC3C,MACE,WAAWA,IACPA,IACAA,EAAgB,QAAQ,sBAAA;YAAsB,CACrD;QAEL;AAEAX,YAA8B,OAC9BC,IAAYG,GACZF,IAAoB,CAAA;MACtB;IACF,WAAWC,EAAa,aAAa,gBAAgB,GAAG;AACtD,YAAMS,IAAgBhB,EAAW;QAC/B,CAACS,MAAYA,EAAQ,YAAYF;MAAA;AAE/BS,UAGFV,EAAkB,KAAKU,CAAa,KAEpCX,IAAY,QACZC,IAAoB,CAAA;IAExB;AACEF,UAA8B;AAIlC,SAAOD;AACT;ACjKO,SAASc,GAAkBf,GAAkBjB,GAAe;AACjE,QAAMiC,IAAQ,iBAAiBhB,CAAO,GAChCiB,IAAW,WAAWD,EAAM,QAAQ;AAE1C,SAAOjC,IAAQkC;AACjB;ACLO,SAASC,GAAmBlB,GAAkBjB,GAAe;AAClE,QAAMiC,IAAQ,iBAAiBhB,EAAQ,cAAc,IAAI,GACnDiB,IAAW,WAAWD,EAAM,QAAQ;AAE1C,SAAOjC,IAAQkC;AACjB;ACLO,SAASE,GAAkBpC,GAAe;AAC/C,SAAQA,IAAQ,MAAO,OAAO;AAChC;ACFO,SAASqC,GAAkBrC,GAAe;AAC/C,SAAQA,IAAQ,MAAO,OAAO;AAChC;ACAO,SAASsC,GACdC,GACmC;AACnC,UAAQ,OAAOA,GAAA;IACb,KAAK;AACH,aAAO,CAACA,GAAM,IAAI;IAEpB,KAAK,UAAU;AACb,YAAMC,IAAU,WAAWD,CAAI;AAE/B,aAAIA,EAAK,SAAS,GAAG,IACZ,CAACC,GAAS,GAAG,IACXD,EAAK,SAAS,IAAI,IACpB,CAACC,GAAS,IAAI,IACZD,EAAK,SAAS,KAAK,IACrB,CAACC,GAAS,KAAK,IACbD,EAAK,SAAS,IAAI,IACpB,CAACC,GAAS,IAAI,IACZD,EAAK,SAAS,IAAI,IACpB,CAACC,GAAS,IAAI,IACZD,EAAK,SAAS,IAAI,IACpB,CAACC,GAAS,IAAI,IAGhB,CAACA,GAAS,GAAG;IACtB;EAAA;AAEJ;ACvBO,SAASC,EAAkB;EAChC,WAAAC;EACA,cAAAC;EACA,WAAAC;AACF,GAIG;AACD,MAAIC;AAEJ,QAAM,CAACN,GAAMO,CAAI,IAAIR,GAAiBM,CAAS;AAE/C,UAAQE,GAAA;IACN,KAAK,KAAK;AACRD,UAAUN,IAAO,MAAOG;AACxB;IACF;IACA,KAAK,MAAM;AACTG,UAASN;AACT;IACF;IACA,KAAK,OAAO;AACVM,UAASV,GAAmBQ,GAAcJ,CAAI;AAC9C;IACF;IACA,KAAK,MAAM;AACTM,UAASb,GAAkBW,GAAcJ,CAAI;AAC7C;IACF;IACA,KAAK,MAAM;AACTM,UAAST,GAAkBG,CAAI;AAC/B;IACF;IACA,KAAK,MAAM;AACTM,UAASR,GAAkBE,CAAI;AAC/B;IACF;EAAA;AAGF,SAAOM;AACT;AC/CO,SAASE,EAAmBC,GAAgB;AACjD,SAAO,WAAWA,EAAO,QAAQ,CAAC,CAAC;AACrC;ACIO,SAASC,GAA0B9D,GAAwB;AAChE,QAAM,EAAE,QAAAE,EAAAA,IAAWF,GAEbuD,IAAYxD,EAA4B,EAAE,OAAAC,EAAAA,CAAO;AACvD,SAAIuD,MAAc,IAGTrD,EAAO,IAAI,CAACmC,OAAa;IAC9B,eAAe;IACf,aAAaA,EAAQ,iBAAiB,gBAAgB;IACtD,aAAa;IACb,SAAS;IACT,SAAS;IACT,SAASA,EAAQ;EAAA,EACjB,IAGGnC,EAAO,IAAsB,CAACE,MAAU;AAC7C,UAAM,EAAE,SAAA0B,GAAS,kBAAAiC,EAAA,IAAqB3D;AAEtC,QAAI4D,IAAgB;AACpB,QAAID,EAAiB,eAAe;AAClC,YAAML,IAASJ,EAAkB;QAC/B,WAAAC;QACA,cAAczB;QACd,WAAWiC,EAAiB;MAAA,CAC7B;AAEDC,UAAgBJ,EAAoBF,IAASH,IAAa,GAAG;IAC/D;AAEA,QAAIU;AACJ,QAAIF,EAAiB,aAAa;AAChC,YAAML,IAASJ,EAAkB;QAC/B,WAAAC;QACA,cAAczB;QACd,WAAWiC,EAAiB;MAAA,CAC7B;AAEDE,UAAcL,EAAoBF,IAASH,IAAa,GAAG;IAC7D;AAEA,QAAIW,IAAU;AACd,QAAIH,EAAiB,SAAS;AAC5B,YAAML,IAASJ,EAAkB;QAC/B,WAAAC;QACA,cAAczB;QACd,WAAWiC,EAAiB;MAAA,CAC7B;AAEDG,UAAUN,EAAoBF,IAASH,IAAa,GAAG;IACzD;AAEA,QAAIY,IAAU;AACd,QAAIJ,EAAiB,SAAS;AAC5B,YAAML,IAASJ,EAAkB;QAC/B,WAAAC;QACA,cAAczB;QACd,WAAWiC,EAAiB;MAAA,CAC7B;AAEDI,UAAUP,EAAoBF,IAASH,IAAa,GAAG;IACzD;AAEA,WAAO;MACL,eAAAS;MACA,aAAaD,EAAiB,gBAAgB;MAC9C,aAAAE;MACA,SAAAC;MACA,SAAAC;MACA,SAAS/D,EAAM;IAAA;EAEnB,CAAC;AACH;ACzEO,IAAMgE,KAAN,MAA4C;EACjDC,KAEI,CAAA;EAEJ,YACEC,GACAC,GACA;AACA,UAAMC,IAAY,KAAKH,GAAaC,CAAI;AACxC,WAAIE,MAAc,SAChB,KAAKH,GAAaC,CAAI,IAAI,CAACC,CAAQ,IAE9BC,EAAU,SAASD,CAAQ,KAC9BC,EAAU,KAAKD,CAAQ,GAIpB,MAAM;AACX,WAAK,eAAeD,GAAMC,CAAQ;IACpC;EACF;EAEA,KAAgCD,GAAYG,GAAoB;AAC9D,UAAMD,IAAY,KAAKH,GAAaC,CAAI;AACxC,QAAIE,MAAc;AAChB,UAAIA,EAAU,WAAW;AACNA,UAAU,CAAC,EACnB,KAAK,MAAMC,CAAI;WACnB;AACL,YAAIC,IAAW,OACXC,IAAc;AAIlB,cAAMC,IAAkB,MAAM,KAAKJ,CAAS;AAC5C,iBAASK,IAAI,GAAGA,IAAID,EAAgB,QAAQC,KAAK;AAC/C,gBAAMN,IAAWK,EAAgBC,CAAC;AAClC,cAAI;AACFN,cAAS,KAAK,MAAME,CAAI;UAC1B,SAASK,GAAO;AACVH,kBAAgB,SAClBD,IAAW,MACXC,IAAcG;UAElB;QACF;AAEA,YAAIJ;AACF,gBAAMC;MAEV;EAEJ;EAEA,qBAAqB;AACnB,SAAKN,KAAe,CAAA;EACtB;EAEA,eACEC,GACAC,GACA;AACA,UAAMC,IAAY,KAAKH,GAAaC,CAAI;AACxC,QAAIE,MAAc,QAAW;AAC3B,YAAMO,IAAQP,EAAU,QAAQD,CAAQ;AACpCQ,WAAS,KACXP,EAAU,OAAOO,GAAO,CAAC;IAE7B;EACF;AACF;AC3EO,SAASC,EACdC,GACAC,GACAC,IAAe,GACf;AACA,SACE,KAAK,IAAIvB,EAAmBqB,CAAM,IAAIrB,EAAmBsB,CAAQ,CAAC,KAClEC;AAEJ;AC4BA,IAAIC,IAAe;EACjB,aAAa;EACb,kBAAkB;IAChB,OAAO;EAAA;EAET,eAAA,oBAAmB,IAAA;AACrB;AAEO,IAAMC,IAAe,IAAIjB,GAAA;AAEzB,SAASkB,IAAc;AAC5B,SAAOF;AACT;AAEO,SAASG,EAAO1E,GAAyC;AAC9D,QAAM2E,IAAe,OAAO3E,KAAU,aAAaA,EAAMuE,CAAK,IAAIvE;AAClE,MAAIuE,MAAUI;AACZ,WAAOJ;AAGT,QAAMK,IAAYL;AAElB,SAAAA,IAAQ;IACN,GAAGA;IACH,GAAGI;EAAA,GAGDA,EAAa,gBAAgB,UAC/BH,EAAa,KAAK,qBAAqBD,EAAM,WAAW,GAGtDI,EAAa,qBAAqB,UACpCH,EAAa,KAAK,0BAA0BD,EAAM,gBAAgB,GAGhEI,EAAa,kBAAkB,WAEjCJ,EAAM,cAAc,QAAQ,CAACvE,GAAOb,MAAU;AAC5Ca,MAAM,wBAAwB,QAAQ,CAAC6E,MAAgB;AACrD,UAAIA,EAAY,aAAa;AAC3B,cAAM,EAAE,QAAQC,EAAAA,IACdF,EAAU,cAAc,IAAIzF,CAAK,KAAK,CAAA;AACxC,YAAI2F,GAAY;AACd,gBAAMC,IAAcZ;YAClBU,EAAY;YACZ7E,EAAM,OAAO6E,EAAY,OAAO;UAAA,GAE5BG,IAAeb;YACnBU,EAAY;YACZC,EAAWD,EAAY,OAAO;UAAA;AAE5BE,eAAe,CAACC,MAClB7F,EAAM,+BAA+B0F,EAAY,OAAO,IACtDC,EAAWD,EAAY,OAAO;QAEpC;MACF;IACF,CAAC;EACH,CAAC,GAEDL,EAAa,KAAK,uBAAuBD,EAAM,aAAa,IAGvDA;AACT;ACvGO,SAASU,GAAarF,GAAaC,GAAa;AACrD,MAAID,EAAE,WAAWC,EAAE;AACjB,WAAO;AAEP,WAASqE,IAAQ,GAAGA,IAAQtE,EAAE,QAAQsE;AACpC,QAAItE,EAAEsE,CAAK,KAAKrE,EAAEqE,CAAK;AACrB,aAAO;AAIb,SAAO;AACT;ACTO,SAASgB,EAAqBd,GAAgBC,GAAkB;AACrE,SAAIF,EAAmBC,GAAQC,CAAQ,IAC9B,IAEAD,IAASC,IAAW,IAAI;AAEnC;ACHO,SAASc,EAAkB;EAChC,kBAAAjC;EACA,MAAAX;AACF,GAGG;AACD,QAAM;IACJ,eAAAY,IAAgB;IAChB,aAAAiC;IACA,SAAA9B,IAAU;IACV,SAAAD,IAAU;EAAA,IACRH;AAEJ,MAAIgC,EAAqB3C,GAAMc,CAAO,IAAI;AACxC,QAAI+B,GAAa;AAEf,YAAMC,KAAgBlC,IAAgBE,KAAW;AAC7C6B,QAAqB3C,GAAM8C,CAAY,IAAI,IAC7C9C,IAAOY,IAEPZ,IAAOc;IAEX;AACEd,UAAOc;AAIX,SAAAd,IAAO,KAAK,IAAIe,GAASf,CAAI,GAC7BA,IAAOQ,EAAmBR,CAAI,GAEvBA;AACT;AC5BO,SAAS+C,EAAoB;EAClC,OAAAxF;EACA,eAAeyF;EACf,kBAAkBC;EAClB,cAAAC;EACA,YAAYC;EACZ,SAAAC;AACF,GAOW;AACT,MAAIxB,EAAmBrE,GAAO,CAAC;AAC7B,WAAOyF;AAGT,QAAMK,IAAgB,OAAO,OAAOL,CAAiB,GAC/CT,IAAa,OAAO,OAAOY,CAAc,GACzCG,IAAa,CAAC,GAAGD,CAAa,GAE9B,CAACE,GAAiBC,CAAgB,IAAIN;AAC5C1G,IAAO+G,KAAmB,MAAM,2BAA2B,GAC3D/G,EAAOgH,KAAoB,MAAM,4BAA4B;AAE7D,MAAIC,IAAe;AAsBjB,MAAIL,MAAY,YAAY;AAC1B;AAEE,YAAMzB,IAAQpE,IAAQ,IAAIiG,IAAmBD,GACvC5C,IAAmBsC,EAAsBtB,CAAK;AACpDnF;QACEmE;QACA,yCAAyCgB,CAAK;MAAA;AAGhD,YAAM;QACJ,eAAAf,IAAgB;QAChB,aAAAiC;QACA,SAAA/B,IAAU;MAAA,IACRH;AAIJ,UAAIkC,GAAa;AACf,cAAMa,IAAWL,EAAc1B,CAAK;AAMpC,YALAnF;UACEkH,KAAY;UACZ,6CAA6C/B,CAAK;QAAA,GAGhDC,EAAmB8B,GAAU9C,CAAa,GAAG;AAC/C,gBAAM+C,IAAa7C,IAAU4C;AAGzBf,YAAqBgB,GAAY,KAAK,IAAIpG,CAAK,CAAC,IAAI,MACtDA,IAAQA,IAAQ,IAAI,IAAIoG,IAAaA;QAGzC;MACF;IACF;AAEA;AAEE,YAAMhC,IAAQpE,IAAQ,IAAIgG,IAAkBC,GACtC7C,IAAmBsC,EAAsBtB,CAAK;AACpDnF;QACEmE;QACA,wCAAwCgB,CAAK;MAAA;AAG/C,YAAM;QACJ,eAAAf,IAAgB;QAChB,aAAAiC;QACA,SAAA/B,IAAU;MAAA,IACRH;AAIJ,UAAIkC,GAAa;AACf,cAAMa,IAAWL,EAAc1B,CAAK;AAMpC,YALAnF;UACEkH,KAAY;UACZ,6CAA6C/B,CAAK;QAAA,GAGhDC,EAAmB8B,GAAU5C,CAAO,GAAG;AACzC,gBAAM6C,IAAaD,IAAW9C;AAG1B+B,YAAqBgB,GAAY,KAAK,IAAIpG,CAAK,CAAC,IAAI,MACtDA,IAAQA,IAAQ,IAAI,IAAIoG,IAAaA;QAGzC;MACF;IACF;EACF;AAIF;AAOE,UAAMC,IAAYrG,IAAQ,IAAI,IAAI;AAElC,QAAIoE,IAAQpE,IAAQ,IAAIiG,IAAmBD,GACvCM,IAAoB;AAGxB,eAAa;AACX,YAAMH,IAAWL,EAAc1B,CAAK;AACpCnF;QACEkH,KAAY;QACZ,6CAA6C/B,CAAK;MAAA;AAOpD,YAAMpE,IAJcqF,EAAkB;QACpC,kBAAkBK,EAAsBtB,CAAK;QAC7C,MAAM;MAAA,CACP,IAC2B+B;AAM5B,UAHAG,KAAqBtG,GACrBoE,KAASiC,GAELjC,IAAQ,KAAKA,KAASsB,EAAsB;AAC9C;IAEJ;AAGA,UAAMa,IAAc,KAAK,IAAI,KAAK,IAAIvG,CAAK,GAAG,KAAK,IAAIsG,CAAiB,CAAC;AACzEtG,QAAQA,IAAQ,IAAI,IAAIuG,IAAcA;EAGxC;AAEA;AAIE,QAAInC,IADepE,IAAQ,IAAIgG,IAAkBC;AAEjD,WAAO7B,KAAS,KAAKA,IAAQsB,EAAsB,UAAQ;AACzD,YAAMc,IAAiB,KAAK,IAAIxG,CAAK,IAAI,KAAK,IAAIkG,CAAY,GAExDC,IAAWL,EAAc1B,CAAK;AACpCnF;QACEkH,KAAY;QACZ,6CAA6C/B,CAAK;MAAA;AAGpD,YAAMqC,IAAaN,IAAWK,GACxBE,IAAWrB,EAAkB;QACjC,kBAAkBK,EAAsBtB,CAAK;QAC7C,MAAMqC;MAAA,CACP;AAED,UAAI,CAACpC,EAAmB8B,GAAUO,CAAQ,MACxCR,KAAgBC,IAAWO,GAE3BX,EAAW3B,CAAK,IAAIsC,GAGlBR,EACG,QAAQ,CAAC,EACT,cAAc,KAAK,IAAIlG,CAAK,EAAE,QAAQ,CAAC,GAAG,QAAW;QACpD,SAAS;MAAA,CACV,KAAK;AAER;AAIAA,UAAQ,IACVoE,MAEAA;IAEJ;EACF;AAOA,MAAIe,GAAaH,GAAYe,CAAU;AAIrC,WAAOH;AAGT;AAEE,UAAMe,IAAa3G,IAAQ,IAAIiG,IAAmBD,GAE5CG,IAAWL,EAAca,CAAU;AACzC1H;MACEkH,KAAY;MACZ,6CAA6CQ,CAAU;IAAA;AAGzD,UAAMF,IAAaN,IAAWD,GACxBQ,IAAWrB,EAAkB;MACjC,kBAAkBK,EAAsBiB,CAAU;MAClD,MAAMF;IAAA,CACP;AAMD,QAHAV,EAAWY,CAAU,IAAID,GAGrB,CAACrC,EAAmBqC,GAAUD,CAAU,GAAG;AAC7C,UAAID,IAAiBC,IAAaC,GAG9BtC,IADepE,IAAQ,IAAIiG,IAAmBD;AAElD,aAAO5B,KAAS,KAAKA,IAAQsB,EAAsB,UAAQ;AACzD,cAAMS,IAAWJ,EAAW3B,CAAK;AACjCnF;UACEkH,KAAY;UACZ,6CAA6C/B,CAAK;QAAA;AAGpD,cAAMqC,IAAaN,IAAWK,GACxBE,IAAWrB,EAAkB;UACjC,kBAAkBK,EAAsBtB,CAAK;UAC7C,MAAMqC;QAAA,CACP;AAQD,YANKpC,EAAmB8B,GAAUO,CAAQ,MACxCF,KAAkBE,IAAWP,GAE7BJ,EAAW3B,CAAK,IAAIsC,IAGlBrC,EAAmBmC,GAAgB,CAAC;AACtC;AAGExG,YAAQ,IACVoE,MAEAA;MAEJ;IACF;EACF;AAKA,QAAM5E,IAAY,OAAO,OAAOuG,CAAU,EAAE;IAC1C,CAACa,GAAOnE,MAASA,IAAOmE;IACxB;EAAA;AAOF,MAAI,CAACvC,EAAmB7E,GAAW,KAAK,GAAG;AAIzC,WAAOoG;AAGT,QAAMiB,IAAiB,OAAO,KAAKjB,CAAc;AAGjD,SAAOG,EAAW,OAAe,CAACe,GAAapF,GAAS0C,OACtD0C,EAAYD,EAAezC,CAAK,CAAC,IAAI1C,GAC9BoF,IACN,CAAA,CAAE;AACP;ACxTO,SAASC,GAAmBC,GAA+B;AAChE,QAAMhG,IAAegG,EAAiB;AACtC/H,IAAO+B,GAAc,gCAAgC;AAErD,QAAM,EAAE,eAAAiG,EAAA,IAAkBtC,EAAA;AAE1B,aAAW,CAACtF,CAAK,KAAK4H;AACpB,QAAI5H,EAAM,YAAY2B;AACpB,aAAO3B;AAIX,QAAM,MAAM,mDAAmD;AACjE;ACbO,SAAS6H,EAAapH,GAAWC,GAAoB;AAC1D,MAAI,OAAO,KAAKD,CAAC,EAAE,WAAW,OAAO,KAAKC,CAAC,EAAE;AAC3C,WAAO;AAGT,aAAWoH,KAAMrH;AAEf,QAAIC,EAAEoH,CAAE,MAAM,UAAa/B,EAAqBtF,EAAEqH,CAAE,GAAGpH,EAAEoH,CAAE,CAAC,MAAM;AAChE,aAAO;AAIX,SAAO;AACT;ACTO,SAASC,EAAyB;EACvC,QAAAC;EACA,kBAAAjE;AACF,GAGW;AAET,QAAM2C,IAAa,CAAC,GADD,OAAO,OAAOsB,CAAM,CACN,GAE3BC,IAAsBvB,EAAW;IACrC,CAACe,GAAapF,MAAYoF,IAAcpF;IACxC;EAAA;AAIF,MAAIqE,EAAW,WAAW3C,EAAiB;AACzC,UAAM;MACJ,WAAWA,EAAiB,MAAM,kBAAkB2C,EACjD,IAAI,CAACtD,MAAS,GAAGA,CAAI,GAAG,EACxB,KAAK,IAAI,CAAC;IAAA;AAEjB,MACE,CAAC4B,EAAmBiD,GAAqB,GAAG,KAC5CvB,EAAW,SAAS;AAEpB,aAAS3B,IAAQ,GAAGA,IAAQhB,EAAiB,QAAQgB,KAAS;AAC5D,YAAMqC,IAAaV,EAAW3B,CAAK;AACnCnF,QAAOwH,KAAc,MAAM,kCAAkCrC,CAAK,EAAE;AACpE,YAAMsC,IAAY,MAAMY,IAAuBb;AAC/CV,QAAW3B,CAAK,IAAIsC;IACtB;AAGF,MAAIa,IAAgB;AAGpB,WAASnD,IAAQ,GAAGA,IAAQhB,EAAiB,QAAQgB,KAAS;AAC5D,UAAMqC,IAAaV,EAAW3B,CAAK;AACnCnF,MAAOwH,KAAc,MAAM,kCAAkCrC,CAAK,EAAE;AAEpE,UAAMsC,IAAWrB,EAAkB;MACjC,kBAAkBjC,EAAiBgB,CAAK;MACxC,MAAMqC;IAAA,CACP;AAEGA,SAAcC,MAChBa,KAAiBd,IAAaC,GAE9BX,EAAW3B,CAAK,IAAIsC;EAExB;AAIA,MAAI,CAACrC,EAAmBkD,GAAe,CAAC;AACtC,aAASnD,IAAQ,GAAGA,IAAQhB,EAAiB,QAAQgB,KAAS;AAC5D,YAAM+B,IAAWJ,EAAW3B,CAAK;AACjCnF,QAAOkH,KAAY,MAAM,kCAAkC/B,CAAK,EAAE;AAClE,YAAMqC,IAAaN,IAAWoB,GACxBb,IAAWrB,EAAkB;QACjC,kBAAkBjC,EAAiBgB,CAAK;QACxC,MAAMqC;MAAA,CACP;AAED,UAAIN,MAAaO,MACfa,KAAiBb,IAAWP,GAC5BJ,EAAW3B,CAAK,IAAIsC,GAGhBrC,EAAmBkD,GAAe,CAAC;AACrC;IAGN;AAGF,QAAMV,IAAiB,OAAO,KAAKQ,CAAM;AAEzC,SAAOtB,EAAW,OAAe,CAACe,GAAapF,GAAS0C,OACtD0C,EAAYD,EAAezC,CAAK,CAAC,IAAI1C,GAC9BoF,IACN,CAAA,CAAE;AACP;AClFO,SAASU,GAA0B;EACxC,SAAAC;AACF,GAE0B;AACxB,QAAMC,IAAO,MAAM;AACjB,UAAM,EAAE,eAAAT,EAAA,IAAkBtC,EAAA;AAC1B,eAAW,CAACtF,GAAOa,CAAK,KAAK+G;AAC3B,UAAI5H,EAAM,OAAOoI;AACf,eAAO,EAAE,OAAApI,GAAO,GAAGa,EAAA;AAIvB,UAAM,MAAM,iCAAiCuH,CAAO,GAAG;EACzD;AAEA,SAAO;IACL,YAAY;AACV,YAAM,EAAE,uBAAAE,GAAuB,QAAAN,EAAA,IAAWK,EAAA;AAE1C,aAAIC,IAIK,CAAA,IAGFN;IACT;IACA,UAAUO,GAAsB;AAC9B,YAAM;QACJ,uBAAAD;QACA,yBAAAE;QACA,OAAAxI;QACA,QAAQ2F;QACR,mBAAA8C;MAAA,IACEJ,EAAA,GAEE3B,IAAaqB,EAAyB;QAC1C,QAAQQ;QACR,kBAAkBC;MAAA,CACnB;AAED,aAAIF,IAMK3C,KAGJkC,EAAalC,GAAYe,CAAU,KACtCnB,EAAO,CAACE,OAAe;QACrB,eAAe,IAAI,IAAIA,EAAU,aAAa,EAAE,IAAIzF,GAAO;UACzD,uBAAAsI;UACA,yBAAAE;UACA,QAAQ9B;UACR,mBAAA+B;QAAA,CACD;MAAA,EACD,GAGG/B;IACT;EAAA;AAEJ;ACtEO,SAASgC,GAAgB1I,GAAwB;AACtD,QAAM,EAAE,eAAA4H,EAAA,IAAkBtC,EAAA,GAEpBqD,IAAef,EAAc,IAAI5H,CAAK;AAC5C,SAAAJ,EAAO+I,GAAc,iBAAiB3I,EAAM,EAAE,YAAY,GAEnD2I;AACT;ACFO,SAASC,EACdjB,GACAhH,GACA;AACA,QAAMX,IAAQ0H,GAAmBC,CAAgB,GAC3CgB,IAAeD,GAAgB1I,CAAK,GAEpC0C,IAAY1C,EAAM,WAAW;IACjC,CAACqC,MAAYA,EAAQ,YAAYsF;EAAA;AAEnC/H,IAAO8C,GAAW,8BAA8B;AAEhD,QAAMxC,IAASyI,EAAa,kBAAkB,IAAIjG,CAAS;AAC3D9C,IAAOM,GAAQ,2BAA2B;AAE1C,QAAMoG,IAAepG,EAAO,IAAI,CAACE,MAAUJ,EAAM,OAAO,QAAQI,CAAK,CAAC,GAGhEuF,IADWwC,GAA0B,EAAE,SAASnI,EAAM,GAAA,CAAI,EACpC,UAAA,GAEtBuI,IAAepC,EAAoB;IACvC,OAAAxF;IACA,eAAegF;IACf,kBAAkBgD,EAAa;IAC/B,cAAArC;IACA,YAAAX;IACA,SAAS;EAAA,CACV,GACKe,IAAaqB,EAAyB;IAC1C,QAAQQ;IACR,kBAAkBI,EAAa;EAAA,CAChC;AAEId,IAAalC,GAAYe,CAAU,KACtCnB,EAAO,CAACE,OAAe;IACrB,eAAe,IAAI,IAAIA,EAAU,aAAa,EAAE,IAAIzF,GAAO;MACzD,uBAAuB2I,EAAa;MACpC,yBAAyBA,EAAa;MACtC,QAAQjC;MACR,mBAAmBiC,EAAa;IAAA,CACjC;EAAA,EACD;AAEN;AC/CO,SAASE,GAAkBC,GAAsB;AACtD,MAAIA,EAAM;AACR;AAGF,QAAMnB,IAAmBmB,EAAM,eAEzB9I,IAAQ0H,GAAmBC,CAAgB;AACjD,MAAI,CAAA3H,EAAM;AAIV,YAAQ8I,EAAM,KAAA;MACZ,KAAK,aAAa;AAChBA,UAAM,eAAA,GAEF9I,EAAM,gBAAgB,cACxB4I,EAAyBjB,GAAkB,CAAC;AAE9C;MACF;MACA,KAAK,aAAa;AAChBmB,UAAM,eAAA,GAEF9I,EAAM,gBAAgB,gBACxB4I,EAAyBjB,GAAkB,EAAE;AAE/C;MACF;MACA,KAAK,cAAc;AACjBmB,UAAM,eAAA,GAEF9I,EAAM,gBAAgB,gBACxB4I,EAAyBjB,GAAkB,CAAC;AAE9C;MACF;MACA,KAAK,WAAW;AACdmB,UAAM,eAAA,GAEF9I,EAAM,gBAAgB,cACxB4I,EAAyBjB,GAAkB,EAAE;AAE/C;MACF;MACA,KAAK,OAAO;AACVmB,UAAM,eAAA,GAKNF,EAAyBjB,GAAkB,GAAG;AAC9C;MACF;MACA,KAAK,SAAS;AACZmB,UAAM,eAAA;AAKN,cAAM9I,IAAQ0H,GAAmBC,CAAgB,GAC3C,EAAE,yBAAAa,GAAyB,QAAAR,GAAQ,mBAAAS,EAAA,IACvCC,GAAgB1I,CAAK,GAEjB0C,IAAY1C,EAAM,WAAW;UACjC,CAACqC,MAAYA,EAAQ,YAAYsF;QAAA;AAEnC/H,UAAO8C,GAAW,8BAA8B;AAEhD,cAAMxC,IAASuI,EAAkB,IAAI/F,CAAS;AAC9C9C,UAAOM,GAAQ,2BAA2B;AAE1C,cAAM6I,IAAe7I,EAAO,CAAC,GACvBwF,IAAc8C,EAAwB;UAC1C,CAACnG,MAAYA,EAAQ,YAAY0G,EAAa;QAAA;AAIhD,YAFAnJ,EAAO8F,GAAa,0BAA0B,GAE1CA,EAAY,aAAa;AAC3B,gBAAMoB,IAAWkB,EAAOe,EAAa,EAAE,GAEjCC,IACJtD,EAAY,kBAAkBoB,IACzB9G,EAAM,+BAA+B+I,EAAa,EAAE,KACrDrD,EAAY,UACZA,EAAY;AAElBkD,YAAyBjB,GAAkBqB,IAAWlC,CAAQ;QAChE;AACA;MACF;MACA,KAAK,MAAM;AACTgC,UAAM,eAAA;AAMN,cAAMG,IAFQvB,GAAmBC,CAAgB,EAEjB,WAAW;UACzC,CAACjF,MAAcA,EAAU;QAAA,GAGrBqC,IAAQ,MAAM,KAAKkE,CAAiB,EAAE;UAC1C,CAAC5G,MAAYA,MAAYyG,EAAM;QAAA;AAEjClJ,UAAOmF,MAAU,MAAM,iBAAiB;AAExC,cAAMmE,IAAYJ,EAAM,WACpB/D,IAAQ,IACNA,IAAQ,IACRkE,EAAkB,SAAS,IAC7BlE,IAAQ,IAAIkE,EAAkB,SAC5BlE,IAAQ,IACR;AAEuBkE,UAAkBC,CAAS,EACnC,MAAA;AACrB;MACF;MACA,KAAK,QAAQ;AACXJ,UAAM,eAAA,GAKNF,EAAyBjB,GAAkB,IAAI;AAC/C;MACF;IAAA;AAEJ;ACtHO,IAAMwB,KAAoB,CAACtI,MAAeA;AAA1C,IACMuI,KAAgB,MAAM;AAAC;AAD7B,IAIMC,KAA6B;AAJnC,IAKMC,KAA6B;AALnC,IAMMC,KAA2B;AANjC,IAOMC,KAA2B;AAPjC,IAUMC,KAA4B;EACvC,QAAQ;EACR,SAAS;AACX;ACxBO,SAASC,GACdzJ,GACA8B,GACAhB,GACA;AACA,MAAI4I,GACArI,IAAc;IAChB,GAAG,IAAA;IACH,GAAG,IAAA;EAAA;AAGL,aAAWsI,KAAa7H,GAAY;AAClC,UAAM0C,IAAO3D,GAA+BC,GAAO6I,EAAU,IAAI;AACjE,YAAQ3J,GAAA;MACN,KAAK,cAAc;AACbwE,UAAK,KAAKnD,EAAY,MACxBqI,IAAmBC,GACnBtI,IAAcmD;AAEhB;MACF;MACA,KAAK,YAAY;AACXA,UAAK,KAAKnD,EAAY,MACxBqI,IAAmBC,GACnBtI,IAAcmD;AAEhB;MACF;IAAA;EAEJ;AAEA,SAAOkF,IACH;IACE,UAAUrI;IACV,WAAWqI;EAAA,IAEb;AACN;AC1CA,IAAIE;AAEG,SAASC,KAA2B;AACzC,SAAID,OAAW,WACT,OAAO,cAAe,aACxBA,KAAS,CAAC,CAAC,WAAW,kBAAkB,EAAE,UAE1CA,KAAS,QAINA;AACT;ACXO,SAASE,GAAalJ,GAAqC;AAChE,SACEA,MAAU,QACV,OAAOA,KAAU,YACjB,cAAcA,KACdA,EAAM,aAAa,KAAK;AAE5B;ACKO,SAASmJ,GACdvJ,GACAC,GACQ;AACR,MAAID,MAAMC,EAAG,OAAM,IAAI,MAAM,iCAAiC;AAE9D,QAAMuJ,IAAY;IAChB,GAAGC,GAAczJ,CAAC;IAClB,GAAGyJ,GAAcxJ,CAAC;EAAA;AAGpB,MAAIyJ;AAGJ,SAAOF,EAAU,EAAE,GAAG,EAAE,MAAMA,EAAU,EAAE,GAAG,EAAE;AAC7CxJ,QAAIwJ,EAAU,EAAE,IAAA,GAChBvJ,IAAIuJ,EAAU,EAAE,IAAA,GAEhBE,IAAkB1J;AAGpBb;IACEuK;IACA;EAAA;AAGF,QAAMC,IAAY;IAChB,GAAGC,GAAYC,GAAsBL,EAAU,CAAC,CAAC;IACjD,GAAGI,GAAYC,GAAsBL,EAAU,CAAC,CAAC;EAAA;AAGnD,MAAIG,EAAU,MAAMA,EAAU,GAAG;AAC/B,UAAMG,IAAWJ,EAAgB,YAE3BK,IAAqB;MACzB,GAAGP,EAAU,EAAE,GAAG,EAAE;MACpB,GAAGA,EAAU,EAAE,GAAG,EAAE;IAAA;AAGtB,QAAIpF,IAAI0F,EAAS;AACjB,WAAO1F,OAAK;AACV,YAAM4F,IAAQF,EAAS1F,CAAC;AACxB,UAAI4F,MAAUD,EAAmB,EAAG,QAAO;AAC3C,UAAIC,MAAUD,EAAmB,EAAG,QAAO;IAC7C;EACF;AAEA,SAAO,KAAK,KAAKJ,EAAU,IAAIA,EAAU,CAAC;AAC5C;AAEA,IAAMM,KACJ;AAGF,SAASC,GAAaC,GAAgC;AAEpD,QAAMC,IAAU,iBAAiBC,GAAWF,CAAI,KAAKA,CAAI,EAAE;AAC3D,SAAOC,MAAY,UAAUA,MAAY;AAC3C;AAGA,SAASE,GAAyBH,GAAgC;AAChE,QAAM9H,IAAQ,iBAAiB8H,CAAI;AAwBnC,SArBI,CAAA,EAAA9H,EAAM,aAAa,WAOrBA,EAAM,WAAW,WAChBA,EAAM,aAAa,YAAY6H,GAAaC,CAAI,MAG/C,CAAC9H,EAAM,UAAU,KACjB,eAAeA,KAASA,EAAM,cAAc,UAC5C,qBAAqBA,KAASA,EAAM,oBAAoB,UAExD,kBAAkBA,KAASA,EAAM,iBAAiB,YAClD,YAAYA,KAASA,EAAM,WAAW,UACtC,kBAAkBA,KAASA,EAAM,iBAAiB,UAClD,eAAeA,KAASA,EAAM,cAAc,aAC5C4H,GAAM,KAAK5H,EAAM,UAAU,KAE3BA,EAAM,4BAA4B;AAGxC;AAGA,SAASwH,GAAsBU,GAAqC;AAClE,MAAInG,IAAImG,EAAM;AAEd,SAAOnG,OAAK;AACV,UAAM+F,IAAOI,EAAMnG,CAAC;AAEpB,QADAjF,EAAOgL,GAAM,cAAc,GACvBG,GAAyBH,CAAI,EAAG,QAAOA;EAC7C;AAEA,SAAO;AACT;AAGA,SAASP,GAAYO,GAAuC;AAC1D,SAAQA,KAAQ,OAAO,iBAAiBA,CAAI,EAAE,MAAM,KAAM;AAC5D;AAGA,SAASV,GAAcU,GAAuC;AAC5D,QAAMX,IAAY,CAAA;AAElB,SAAOW;AACLX,MAAU,KAAKW,CAAI,GAEnBA,IAAOE,GAAWF,CAAI;AAGxB,SAAOX;AACT;AAGA,SAASa,GAAWF,GAAmB;AACrC,QAAM,EAAE,YAAAK,EAAAA,IAAeL;AACvB,SAAIb,GAAakB,CAAU,IAClBA,EAAW,OAEbA;AACT;AC5IO,SAASC,GAAiBzK,GAASC,GAAkB;AAC1D,SACED,EAAE,IAAIC,EAAE,IAAIA,EAAE,SACdD,EAAE,IAAIA,EAAE,QAAQC,EAAE,KAClBD,EAAE,IAAIC,EAAE,IAAIA,EAAE,UACdD,EAAE,IAAIA,EAAE,SAASC,EAAE;AAEvB;ACIO,SAASyK,GAAkB;EAChC,cAAAxJ;EACA,WAAAiI;EACA,oBAAAwB;AACF,GAIG;AACD,MACE,CAACxK,GAAcwK,CAAkB,KACjCA,EAAmB,SAASzJ,CAAY,KACxCA,EAAa,SAASyJ,CAAkB;AAIxC,WAAO;AAGT,MAAIpB,GAAQoB,GAAoBzJ,CAAY,IAAI,GAAG;AAOjD,QAAI0J,IAAkDD;AACtD,WAAOC,KAAgB;AACrB,UAAIA,EAAe,SAAS1J,CAAY;AACtC,eAAO;UAEPuJ,GAAiBG,EAAe,sBAAA,GAAyBzB,CAAS;AAElE,eAAO;AAGTyB,UAAiBA,EAAe;IAClC;EACF;AAEA,SAAO;AACT;AC5CO,SAASC,GACdxC,GACAlB,GACa;AACb,QAAM2D,IAAkC,CAAA;AAExC,SAAA3D,EAAc,QAAQ,CAAC4D,GAAGC,MAAc;AACtC,QAAIA,EAAU;AACZ;AAGF,UAAMC,IAAc5B,GAAA,IAChBL,GAA0B,SAC1BA,GAA0B,SAExB1H,IAAaL,GAAoB+J,CAAS,GAC1CE,IAAQjC,GAAoB+B,EAAU,aAAa1J,GAAY;MACnE,GAAG+G,EAAM;MACT,GAAGA,EAAM;IAAA,CACV;AAGC6C,SACAA,EAAM,SAAS,KAAKD,KACpBC,EAAM,SAAS,KAAKD,KACpBP,GAAkB;MAChB,cAAcM,EAAU;MACxB,WAAWE,EAAM,UAAU;MAC3B,oBAAoB7C,EAAM;IAAA,CAC3B,KAEDyC,EAAmB,KAAKI,EAAM,SAAS;EAE3C,CAAC,GAEMJ;AACT;ACxCO,SAASK,GAAsB9C,GAAqB;AACzD,MAAIA,EAAM;AACR;AAGF,QAAM,EAAE,eAAAlB,EAAA,IAAkBtC,EAAA,GAEpBvD,IAAauJ,GAAuBxC,GAAOlB,CAAa,GAExDiE,IAAAA,oBAAa,IAAA,GACb3L,IAAAA,oBAAa,IAAA,GACb0B,IAAAA,oBAAiB,IAAA,GACjBkK,IAAAA,oBAAuB,IAAA;AAE7B,MAAIC,IAAiB;AAErBhK,IAAW,QAAQ,CAACM,MAAY;AAC9BwJ,MAAO,IAAIxJ,EAAQ,KAAK,GACxBA,EAAQ,OAAO,QAAQ,CAACjC,MAAU;AAChCF,QAAO,IAAIE,CAAK;IAClB,CAAC,GAEGiC,EAAQ,cACVT,EAAW,IAAIS,EAAQ,SAAS,GAE3B0J,MACHA,IAAiB,MAEjB1J,EAAQ,UAAU,QAAQ,MAAA;AAI9B,UAAMsJ,IAAQ/D,EAAc,IAAIvF,EAAQ,KAAK;AACzCsJ,SACFG,EAAiB,IAAIzJ,EAAQ,OAAOsJ,EAAM,MAAM;EAEpD,CAAC,GAEDpG,EAAO;IACL,kBAAkB;MAChB,YAAAxD;MACA,kBAAA+J;MACA,oBAAoB,EAAE,GAAGhD,EAAM,SAAS,GAAGA,EAAM,QAAA;MACjD,OAAO;IAAA;EACT,CACD,GAEG/G,EAAW,UACb+G,EAAM,eAAA;AAEV;AC9CO,SAASkD,GAAe;EAC7B,aAAAC;EACA,QAAAJ;EACA,OAAAzG;AACF,GAIgC;AAC9B,MAAI8G,IAAkB,GAClBC,IAAgB;AAEpB,UAAQ/G,GAAA;IACN,KAAK;IACL,KAAK;AACHyG,QAAO,QAAQ,CAAC7L,MAAU;AACxB,YAAI,CAAAA,EAAM;AAIV,kBAAQA,EAAM,aAAA;YACZ,KAAK,cAAc;AACjBkM;AACA;YACF;YACA,KAAK,YAAY;AACfC;AACA;YACF;UAAA;MAEJ,CAAC;EACH;AAGF,MAAID,MAAoB,KAAKC,MAAkB;AAC7C,WAAO;AAGT,UAAQ/G,GAAA;IACN,KAAK,UAAU;AACb,YAAMgH,KAAiBH,IAAc5C,QAAgC,GAC/DgD,KAAiBJ,IAAc3C,QAAgC,GAC/DgD,KAAeL,IAAc1C,QAA8B,GAC3DgD,KAAeN,IAAczC,QAA8B;AAEjE,UAAIyC,GAAa;AACf,YAAIG;AACF,iBAAIE,IACK,cACEC,IACF,cAEA;YAEAF;AACT,iBAAIC,IACK,cACEC,IACF,cAEA;YAEAD;AACT,iBAAO;YACEC;AACT,iBAAO;MAEX;AACA;IACF;EAAA;AAGF,SAAIL,IAAkB,KAAKC,IAAgB,IAClC,SACED,IAAkB,IACpB,cAEA;AAEX;ACtFA,IAAMM,KAAAA,oBAAyB,QAAA;AAQxB,SAASC,GAAkBC,GAAyB;AAGzD,MACEA,EAAc,gBAAgB,QAC9BA,EAAc,gBAAgB;AAE9B;AAGF,MAAI,EAAE,WAAAC,GAAW,YAAAC,EAAA,IAAeJ,GAAmB,IAAIE,CAAa,KAAK,CAAA;AAErEE,QAAe,WACjBA,IAAa,IAAIF,EAAc,YAAY,cAAA,GAE3CA,EAAc,qBAAqB,CAACE,CAAU;AAGhD,QAAM,EAAE,aAAAX,GAAa,kBAAAY,EAAA,IAAqBvH,EAAA;AAE1C,UAAQuH,EAAiB,OAAA;IACvB,KAAK;IACL,KAAK,SAAS;AACZ,YAAMC,IAAcd,GAAe;QACjC,aAAAC;QACA,QAAQY,EAAiB,WAAW,IAAI,CAACxK,MAAYA,EAAQ,KAAK;QAClE,OAAOwK,EAAiB;MAAA,CACzB,GAEKE,IAAY,aAAaD,CAAW,gBAAgBD,EAAiB,UAAU,WAAW,wBAAwB,EAAE;AAC1H,UAAIF,MAAcI;AAChB;AAGFJ,UAAYI,GAERD,IACEF,EAAW,SAAS,WAAW,IACjCA,EAAW,WAAWG,CAAS,IAE/BH,EAAW,YAAYG,CAAS,IAEzBH,EAAW,SAAS,WAAW,KACxCA,EAAW,WAAW,CAAC;AAEzB;IACF;IACA,KAAK,YAAY;AACfD,UAAY,QAERC,EAAW,SAAS,WAAW,KACjCA,EAAW,WAAW,CAAC;AAEzB;IACF;EAAA;AAGFJ,KAAmB,IAAIE,GAAe;IACpC,WAAAC;IACA,YAAAC;EAAA,CACD;AACH;AC1DO,SAASI,GAAuB;EACrC,UAAAC;EACA,OAAAnE;EACA,YAAA/G;EACA,kBAAA+J;EACA,eAAAlE;EACA,oBAAAsF;AACF,GAUG;AACD,MAAIjB,IAAc;AAClB,QAAMkB,IAAoB,IAAI,IAAIvF,CAAa;AAI/C7F,IAAW,QAAQ,CAACM,MAAY;AAC9B,UAAM,EAAE,OAAArC,GAAO,WAAAuD,EAAA,IAAclB,GACvB,EAAE,eAAA+K,GAAe,aAAAnN,GAAa,QAAAC,EAAA,IAAWF;AAE/C,QAAIqN,IAAoB;AACpBH,QACEjN,MAAgB,eAClBoN,KACIvE,EAAM,UAAUoE,EAAmB,KAAK3J,IAAa,MAEzD8J,KACIvE,EAAM,UAAUoE,EAAmB,KAAK3J,IAAa,MAGvDtD,MAAgB,eAClBoN,IAAoBvE,EAAM,UAAU,IAAI,OAAO,MAE/CuE,IAAoBvE,EAAM,UAAU,IAAI,OAAO;AAInD,UAAMrC,IAAgBqF,EAAiB,IAAI9L,CAAK,GAE1C;MACJ,uBAAAsI;MACA,yBAAAE;MACA,QAAQ7C;MACR,mBAAA8C;IAAA,IACEb,EAAc,IAAI5H,CAAK,KAAK,EAAE,uBAAuB,MAAA;AACzD,QACEwI,KACA/B,KACAd,KACA8C,GACA;AACA,YAAM/B,IAAaP,EAAoB;QACrC,OAAOkH;QACP,eAAA5G;QACA,kBAAkB+B;QAClB,cAAcnG,EAAQ,OAAO,IAAI,CAACjC,MAAUF,EAAO,QAAQE,CAAK,CAAC;QACjE,YAAAuF;QACA,SAAS;MAAA,CACV;AAED,UAAIkC,EAAanB,GAAYf,CAAU,GAAA;AACrC,YAAI0H,MAAsB,KAAK,CAACD;AAE9B,kBAAQnN,GAAA;YACN,KAAK,cAAc;AACjBgM,mBACEoB,IAAoB,IAChBhE,KACAC;AACN;YACF;YACA,KAAK,YAAY;AACf2C,mBACEoB,IAAoB,IAChB9D,KACAC;AACN;YACF;UAAA;MAAA,OAGC;AACL2D,UAAkB,IAAI9K,EAAQ,OAAO;UACnC,uBAAAiG;UACA,yBAAAE;UACA,QAAQ9B;UACR,mBAAA+B;QAAA,CACD;AAID,cAAM6E,IAAcjL,EAAQ,MAAM,OAAO,IAAI,CAAC,EAAE,IAAAyF,EAAAA,MAASA,CAAE,EAAE,KAAK,GAAG;AACrEzF,UAAQ,MAAM,gBAAgBiL,CAAW,IAAI5G;MAC/C;IACF;EACF,CAAC,GAEDnB,EAAO;IACL,aAAA0G;IACA,eAAekB;EAAA,CAChB,GAEDV,GAAkBQ,CAAQ;AAC5B;ACxHO,SAASM,GAAuBzE,GAAqB;AAC1D,QAAM,EAAE,kBAAA+D,GAAkB,eAAAjF,EAAA,IAAkBtC,EAAA;AAE5C,UAAQuH,EAAiB,OAAA;IACvB,KAAK;AACHG,SAAuB;QACrB,UAAUlE,EAAM;QAChB,OAAAA;QACA,YAAY+D,EAAiB;QAC7B,kBAAkBA,EAAiB;QACnC,eAAAjF;MAAA,CACD;EACH;AAEJ;ACZO,SAAS4F,GAAsB1E,GAAqB;AACzD,MAAIA,EAAM;AACR;AAGF,QAAM,EAAE,kBAAA+D,GAAkB,eAAAjF,EAAA,IAAkBtC,EAAA;AAE5C,UAAQuH,EAAiB,OAAA;IACvB,KAAK,UAAU;AAGb;;QAEE/D,EAAM,YAAY;QAClB;AACAvD;UAAO,CAACE,MACNA,EAAU,iBAAiB,UAAU,aACjCA,IACA;YACE,aAAa;YACb,kBAAkB;cAChB,OAAO;YAAA;UACT;QACF;AAGN;MACF;AAEAuH,SAAuB;QACrB,UAAUlE,EAAM;QAChB,OAAAA;QACA,YAAY+D,EAAiB;QAC7B,kBAAkBA,EAAiB;QACnC,eAAAjF;QACA,oBAAoBiF,EAAiB;MAAA,CACtC;AACD;IACF;IACA,SAAS;AAEP,YAAM9K,IAAauJ,GAAuBxC,GAAOlB,CAAa;AAE1D7F,QAAW,WAAW,IACpB8K,EAAiB,UAAU,cAC7BtH,EAAO;QACL,kBAAkB,EAAE,OAAO,WAAA;MAAW,CACvC,IAGHA,EAAO;QACL,kBAAkB;UAChB,YAAAxD;UACA,OAAO;QAAA;MACT,CACD,GAGH0K,GAAkB3D,EAAM,aAAyB;AACjD;IACF;EAAA;AAEJ;AChEO,SAAS2E,GAAoB3E,GAAqB;AACvD,MAAIA,EAAM;AACR;AAGFA,IAAM,eAAA;AAEN,QAAM,EAAE,kBAAA+D,EAAA,IAAqBvH,EAAA;AAE7B,UAAQuH,EAAiB,OAAA;IACvB,KAAK;AACHtH,QAAO;QACL,aAAa;QACb,kBAAkB;UAChB,OAAO;QAAA;MACT,CACD,GAEDkH,GAAkB3D,EAAM,aAAyB;EACnD;AAEJ;ACpBO,SAAS4E,GACdlF,GACQ;AACR,MAAImF,IAAgB,GAChBpG,IAAQ;AAEZ,QAAMS,IAAiB,CAAA;AAEvB,aAAW3F,KAAWmG;AACpB,QAAInG,EAAQ,gBAAgB,QAAW;AACrCsL;AAEA,YAAMvK,IAAOQ,EAAmBvB,EAAQ,WAAW;AAEnDkF,WAASnE,GACT4E,EAAO3F,EAAQ,OAAO,IAAIe;IAC5B;AAEE4E,QAAO3F,EAAQ,OAAO,IAAI;AAI9B,QAAMuL,IAAsBpF,EAAwB,SAASmF;AAC7D,MAAIC,MAAwB,GAAG;AAC7B,UAAMxK,IAAOQ,GAAoB,MAAM2D,KAASqG,CAAmB;AAEnE,eAAWvL,KAAWmG;AAChBnG,QAAQ,gBAAgB,WAC1B2F,EAAO3F,EAAQ,OAAO,IAAIe;EAGhC;AAEA,SAAO4E;AACT;AClCO,SAAS6F,GACd7N,GACA8B,GACAgM,GACA;AACA,QAAMC,IAAqBD,EAAc,CAAC;AAC1C,MAAI,CAACC;AACH;AAGF,QAAM3N,IAAQJ,EAAM,OAAO,KAAK,CAACqC,MAAYA,EAAQ,YAAYP,CAAO;AACxE,MAAI,CAAC1B,KAAS,CAACA,EAAM;AACnB;AAGF,QAAMmD,IAAYxD,EAA4B,EAAE,OAAAC,EAAAA,CAAO,GAEjD8G,IAAW1G,EAAM,cAAc,UAC/B4I,IAAW;IACf,cAAcpF;MACXmK,EAAmB,aAAaxK,IAAa;IAAA;IAEhD,UAAUwK,EAAmB;EAAA;AAE/B3N,IAAM,cAAc,WAAW4I,GAE/B5I,EAAM,SAAS4I,GAAU5I,EAAM,IAAI0G,CAAQ;AAC7C;AC/BO,SAASkH,GAAavN,GAAWC,GAAW;AAEjD,MADa,OAAO,KAAKD,CAAC,EACjB,WAAW,OAAO,KAAKC,CAAC,EAAE;AACjC,WAAO;AAGT,aAAWuN,KAAOxN;AAChB,QAAIA,EAAEwN,CAAqB,MAAMvN,EAAEuN,CAAqB;AACtD,aAAO;AAIX,SAAO;AACT;ACVO,SAASC,GAAmBhO,GAA2B8H,GAAgB;AAC5E,QAAMmG,IAAWjO,EAAO,IAAI,CAACE,MAAUA,EAAM,EAAE,GACzCgO,IAAa,OAAO,KAAKpG,CAAM;AAErC,MAAImG,EAAS,WAAWC,EAAW;AACjC,WAAO;AAGT,aAAWC,KAAWF;AACpB,QAAI,CAACC,EAAW,SAASC,CAAO;AAC9B,aAAO;AAIX,SAAO;AACT;ACAA,IAAMC,IAAAA,oBAAmC,IAAA;AAElC,SAASC,GAAWvO,GAAwB;AACjD,MAAIwO,IAAY;AAEhB5O;IACEI,EAAM,QAAQ,cAAc;IAC5B;EAAA;AAGF,QAAMyO,IAAiBzO,EAAM,QAAQ,cAAc,YAAY,gBAEzDmO,IAAAA,oBAAe,IAAA,GACfO,IAAAA,oBAAmB,IAAA,GAInBC,IAAiB,IAAIF,EAAe,CAACG,MAAY;AACrD,eAAWC,KAASD,GAAS;AAC3B,YAAM,EAAE,eAAAd,GAAe,QAAAgB,EAAA,IAAWD;AAClC,UAAIC,MAAW9O,EAAM,SAAA;AACnB,YAAIwO,GAAW;AAEb,cADkBzO,EAA4B,EAAE,OAAAC,EAAAA,CAAO,MACrC;AAGhB;AAGFuF,YAAO,CAACE,MAAc;AACpB,kBAAMkG,IAAQlG,EAAU,cAAc,IAAIzF,CAAK;AAC/C,gBAAI2L,GAAO;AAET,oBAAMoD,IACJjL,GAA0B9D,CAAK,GAG3B2F,IAAagG,EAAM,wBACrB+B,GAAuBqB,CAA2B,IAClDpD,EAAM,QACJjF,IAAaqB,EAAyB;gBAC1C,QAAQpC;gBACR,kBAAkBoJ;cAAA,CACnB;AAED,qBACE,CAACpD,EAAM,yBACP9D,EAAalC,GAAYe,CAAU,KACnCsH;gBACErC,EAAM;gBACNoD;cAAA,IAGKtJ,IAGF;gBACL,eAAe,IAAI,IAAIA,EAAU,aAAa,EAAE,IAAIzF,GAAO;kBACzD,uBAAuB;kBACvB,yBAAyB+O;kBACzB,QAAQrI;kBACR,mBAAmBiF,EAAM;gBAAA,CAC1B;cAAA;YAEL;AAEA,mBAAOlG;UACT,CAAC;QACH;MAAA;AAEAoI,WAAoB7N,GAAO8O,GAAuBhB,CAAa;IAEnE;EACF,CAAC;AACDa,IAAe,QAAQ3O,EAAM,OAAO,GACpCA,EAAM,OAAO,QAAQ,CAACI,MAAU;AAC9BR;MACE,CAACuO,EAAS,IAAI/N,EAAM,EAAE;MACtB,iCAAiCA,EAAM,EAAE;IAAA,GAG3C+N,EAAS,IAAI/N,EAAM,EAAE,GAEjBA,EAAM,YACRuO,EAAe,QAAQvO,EAAM,OAAO;EAExC,CAAC;AAED,QAAMmD,IAAYxD,EAA4B,EAAE,OAAAC,EAAAA,CAAO,GAGjDwI,IAA0B1E,GAA0B9D,CAAK,GACzDsN,IAActN,EAAM,OAAO,IAAI,CAAC,EAAE,IAAA8H,EAAA,MAASA,CAAE,EAAE,KAAK,GAAG;AAK7D,MAAIkH,IAAoChP,EAAM;AAC1CgP,QACGd,GAAmBlO,EAAM,QAAQgP,CAAa,MACjDA,IAAgB;AAIpB,QAAMC,IACJjP,EAAM,gBAAgBsN,CAAW,KACjC0B,KACAtB,GAAuBlF,CAAuB,GAC1C0G,IAAoBnH,EAAyB;IACjD,QAAQkH;IACR,kBAAkBzG;EAAA,CACnB,GAEKzG,IAAaL,GAAoB1B,CAAK,GAEtC0M,IAAgB1M,EAAM,QAAQ;AAEpC,SAAAuF,EAAO,CAACE,MAAc;AACpB,UAAMgD,IAAAA,oBAA8C,IAAA;AAEpD,WAAA6F,EAA6B;MAC3B5B;OACC4B,EAA6B,IAAI5B,CAAa,KAAK,KAAK;IAAA,GAG3D3K,EAAW,QAAQ,CAAC6H,MAAc;AAC5BA,QAAU,aACZnB,EAAkB,IAAImB,EAAU,WAAWA,EAAU,MAAM;IAE/D,CAAC,GAEM;MACL,eAAe,IAAI,IAAInE,EAAU,aAAa,EAAE,IAAIzF,GAAO;QACzD,uBAAuBuD,MAAc;QACrC,yBAAAiF;QACA,QAAQ0G;QACR,mBAAAzG;MAAA,CACD;IAAA;EAEL,CAAC,GAEDzI,EAAM,WAAW,QAAQ,CAAC0C,MAAc;AACtC9C;MACE,CAAC8O,EAAa,IAAIhM,EAAU,EAAE;MAC9B,qCAAqCA,EAAU,EAAE;IAAA,GAGnDgM,EAAa,IAAIhM,EAAU,EAAE,GAE7BA,EAAU,QAAQ,iBAAiB,WAAWmG,EAAiB;EACjE,CAAC,GAGGyF,EAA6B,IAAI5B,CAAa,MAAM,MACtDA,EAAc,iBAAiB,eAAed,EAAqB,GACnEc,EAAc,iBAAiB,gBAAgBa,EAAsB,GACrEb,EAAc,iBAAiB,eAAec,EAAqB,GACnEd,EAAc,iBAAiB,aAAae,EAAmB,IAG1D,WAAwB;AAC7Be,QAAY,OAEZF,EAA6B;MAC3B5B;MACA,KAAK,IAAI,IAAI4B,EAA6B,IAAI5B,CAAa,KAAK,KAAK,CAAC;IAAA,GAGxEnH,EAAO,CAACE,MAAc;AACpB,YAAMmC,IAAgB,IAAI,IAAInC,EAAU,aAAa;AACrD,aAAAmC,EAAc,OAAO5H,CAAK,GAEnB,EAAE,eAAA4H,EAAA;IACX,CAAC,GAED5H,EAAM,WAAW,QAAQ,CAAC0C,MAAc;AACtCA,QAAU,QAAQ,oBAAoB,WAAWmG,EAAiB;IACpE,CAAC,GAGIyF,EAA6B,IAAI5B,CAAa,MACjDA,EAAc,oBAAoB,eAAed,EAAqB,GACtEc,EAAc,oBAAoB,gBAAgBa,EAAsB,GACxEb,EAAc,oBAAoB,eAAec,EAAqB,GACtEd,EAAc,oBAAoB,aAAae,EAAmB,IAGpEkB,EAAe,WAAA;EACjB;AACF;AC7MO,SAASQ,KAAiB;AAC/B,QAAM,CAACC,GAAOC,CAAQ,QAAIC,aAAAA,UAAS,CAAA,CAAE,GAE/BC,QAAcC,aAAAA,aAAY,MAAMH,EAAS,CAAA,CAAE,GAAG,CAAA,CAAE;AAEtD,SAAO,CAACD,GAAkBG,CAAW;AACvC;ACNO,SAASE,GAAMC,GAAuC;AAC3D,QAAMC,QAAYC,aAAAA,OAAA;AAElB,SAAO,GAAGF,KAAYC,CAAS;AACjC;ACJO,IAAME,IACX,OAAO,SAAW,MAAcC,aAAAA,kBAAkBC,aAAAA;ACE7C,SAASC,GACdC,GACU;AACV,QAAMC,QAAMC,aAAAA,QAAiBF,CAAE;AAE/B,SAAAJ,EAA0B,MAAM;AAC9BK,MAAI,UAAUD;EAChB,GAAG,CAACA,CAAE,CAAC,OAEAT,aAAAA;IACL,IAAIY,MAAoBF,EAAI,UAAU,GAAGE,CAAI;IAC7C,CAACF,CAAG;EAAA;AAER;ACbO,SAASG,MAAuBC,GAA2B;AAChE,SAAON,GAAkB,CAACnP,MAAuB;AAC/CyP,MAAK,QAAQ,CAACJ,MAAQ;AACpB,UAAIA;AACF,gBAAQ,OAAOA,GAAA;UACb,KAAK,YAAY;AACfA,cAAIrP,CAAK;AACT;UACF;UACA,KAAK,UAAU;AACbqP,cAAI,UAAUrP;AACd;UACF;QAAA;IAGN,CAAC;EACH,CAAC;AACH;ACnBO,SAAS0P,GACdC,GACM;AACN,QAAMN,QAAMC,aAAAA,QAAa,EAAE,GAAGK,EAAAA,CAAgB;AAE9C,SAAAX,EAA0B,MAAM;AAC9B,eAAW5B,KAAOuC;AAChBN,QAAI,QAAQjC,CAAG,IAAIuC,EAAevC,CAAG;EAEzC,GAAG,CAACuC,CAAc,CAAC,GAEZN,EAAI;AACb;ACfO,IAAMO,KACX;ACDK,SAASC,GAA4BtI,GAAiBiG,GAAiB;AAC5E,QAAMsC,IAAiBvI,EAAQ,QAAQ,oBAAoB,EAAE,GACvDwI,IAAiBvC,EAAQ,QAAQ,oBAAoB,EAAE;AAE7D,SAAO,6BAA6BsC,CAAc,KAAKC,CAAc;AACvE;ACFO,IAAMC,SAAeC,aAAAA,eAAuC,IAAI;ACGhE,SAASC,GACd3I,GACA4I,GACA;AACA,QAAMC,QAAqBd,aAAAA,QAA8B;IACvD,WAAW,OAAO,CAAA;IAClB,WAAWhH;EAAA,CACZ;AAED+H,mBAAAA,qBAAoBF,GAAU,MAAMC,EAAmB,SAAS,CAAA,CAAE,GAElEpB,EAA0B,MAAM;AAC9B,WAAO;MACLoB,EAAmB;MACnB9I,GAA0B,EAAE,SAAAC,EAAA,CAAS;IAAA;EAEzC,CAAC;AACH;ACSO,SAAS+I,GAAM;EACpB,UAAA5G;EACA,WAAA6G;EACA,eAAApC;EACA,eAAA5B;EACA,UAAAiE;EACA,YAAYC;EACZ,UAAAN;EACA,IAAIO;EACJ,gBAAgBC;EAChB,aAAAvR,IAAc;EACd,OAAA6C;EACA,GAAG2O;AACL,GAAe;AACb,QAAMC,QAAgBvB,aAAAA,QAAe,CAAA,CAAE,GAEjCwB,IAAuB3B,GAAkB,CAAChI,MAAmB;AAC7DH,MAAa6J,EAAc,SAAS1J,CAAM,MAK9C0J,EAAc,UAAU1J,GACxBwJ,IAAyBxJ,CAAM;EACjC,CAAC,GAEKF,IAAK2H,GAAM8B,CAAM,GAEjBK,QAAazB,aAAAA,QAA8B,IAAI,GAE/C,CAAC0B,GAAYC,CAAa,QAAIxC,aAAAA,UAAS,KAAK,GAC5C,CAACtH,GAAQ+J,CAAS,QAAIzC,aAAAA,UAASN,KAAiB,CAAA,CAAE,GAClD,CAACgD,GAA6BzC,CAAW,IAAIJ,GAAA,GAE7C8C,QAAoB9B,aAAAA,QAKvB;IACD,wBAAwB,CAAA;IACxB,SAAS,CAAA;IACT,QAAQ,CAAA;IACR,YAAY,CAAA;EAAC,CACd,GAEK+B,IAAY7B,GAAcuB,GAAYN,CAAc;AAE1DP,KAAyBjJ,GAAIkJ,CAAQ;AAErC,QAAMmB,QAAUC,aAAAA;IACd,OAAO;MACL,IAAAtK;MACA,aAAA7H;MACA,eAAe,CAACG,MAA2B;AACzC,cAAMiS,IAAiBJ,EAAkB;AACzC,eAAAI,EAAe,SAAShS,GAAoBJ,GAAa;UACvD,GAAGoS,EAAe;UAClBjS;QAAA,CACD,GAEDmP,EAAA,GAEO,MAAM;AACX8C,YAAe,SAASA,EAAe,OAAO;YAC5C,CAAChQ,MAAYA,MAAYjC;UAAA,GAG3BmP,EAAA;QACF;MACF;MACA,mBAAmB,CAAC7M,MAAmC;AACrD,cAAM2P,IAAiBJ,EAAkB;AACzC,eAAAI,EAAe,aAAahS,GAAoBJ,GAAa;UAC3D,GAAGoS,EAAe;UAClB3P;QAAA,CACD,GAED6M,EAAA,GAEO,MAAM;AACX8C,YAAe,aAAaA,EAAe,WAAW;YACpD,CAAChQ,MAAYA,MAAYK;UAAA,GAG3B6M,EAAA;QACF;MACF;IAAA;IAEF,CAACzH,GAAIyH,GAAatP,CAAW;EAAA,GAGzBqS,IAAc/B,GAAgB;IAClC,eAAAvB;IACA,eAAA5B;EAAA,CACD,GAEKmF,QAAqBpC,aAAAA,QAA+B,IAAI;AAI9DN,IAA0B,MAAM;AAC9B,UAAM/N,IAAU8P,EAAW;AAC3B,QAAI9P,MAAY;AACd;AAGF,UAAMuQ,IAAiBJ,EAAkB,SAEnCjS,IAAyB;MAC7B,eAAesS,EAAY;MAC3B,eAAe,CAAC,CAACA,EAAY;MAC7B,UAAU,CAAC,CAACjB;MACZ,SAAAvP;MACA,IAAAgG;MACA,gCACEmK,EAAkB,QAAQ;MAC5B,iBAAiBA,EAAkB,QAAQ;MAC3C,aAAAhS;MACA,QAAQoS,EAAe;MACvB,YAAYA,EAAe;IAAA;AAG7BE,MAAmB,UAAUvS;AAE7B,UAAMwS,KAAejE,GAAWvO,CAAK,GAG/B2L,KADcrG,EAAA,EACM,cAAc,IAAItF,CAAK;AACjD,QAAI2L,IAAO;AACT,YAAM,EAAE,uBAAArD,GAAuB,yBAAAE,GAAyB,QAAAR,EAAAA,IAAW2D;AAE/D,OAACrD,KAAyBE,EAAwB,SAAS,MAC7DuJ,EAAU/J,CAAM,GAEhB2J,IAAuB3J,CAAM;IAEjC;AAEA,UAAMyK,KAAuCpN,EAAa;MACxD;MACA,CAACwH,MAAqB;AACpB,gBAAQA,EAAiB,OAAA;UACvB,KAAK,UAAU;AACbiF;cACEjF,EAAiB,WAAW;gBAC1B,CAACxK,MAAYA,EAAQ,UAAUrC;cAAA;YACjC;AAEF;UACF;UACA,SAAS;AACP8R,cAAc,KAAK;AACnB;UACF;QAAA;MAEJ;IAAA,GAGIY,KAAyCrN,EAAa;MAC1D;MACA,CAACuC,MAAkB;AACjB,cAAM+D,IAAQ/D,EAAc,IAAI5H,CAAK;AACrC,YAAI2L,GAAO;AACT,gBAAM,EAAE,uBAAArD,GAAuB,yBAAAE,IAAyB,QAAAR,GAAAA,IACtD2D;AAEF,cAAIrD,KAAyBE,GAAwB,WAAW;AAI9D;AAGFuJ,YAAU/J,EAAM,GAEhB2J,IAAuB3J,EAAM;QAC/B;MACF;IAAA;AAGF,WAAO,MAAM;AACXuK,QAAmB,UAAU,MAE7BC,GAAA,GACAC,GAAA,GACAC,GAAA;IACF;EACF,GAAG;IACDrB;IACAvJ;IACA6J;IACA1R;IACA+R;IACAM;EAAA,CACD,OAIDvC,aAAAA,WAAU,MAAM;AACd,UAAM4C,IAAkBJ,EAAmB;AACvCI,UACFA,EAAgB,gBAAgB3D,GAChC2D,EAAgB,gBAAgB,CAAC,CAACvF;EAEtC,CAAC;AAGD,QAAMwF,IAA+D;IACnE,CAACnC,EAAgC,GAAGoB,IAAa,SAAS;EAAA;AAE5D,aAAWxD,KAAWrG,GAAQ;AAC5B,UAAM6K,IAAenC,GAA4B5I,GAAIuG,CAAO,GACtDyE,IAAW9K,EAAOqG,CAAO;AAC/BuE,MAAaC,CAAY,IAAIC;EAC/B;AAEA,aACEC,mBAAAA,KAAClC,GAAa,UAAb,EAAsB,OAAOsB,GAC5B,cAAAY,mBAAAA;IAAC;IAAA;MACE,GAAGtB;MACJ,oBAAkBxR;MAClB,WAAAmR;MACA,cAAU;MACV,eAAatJ;MACb,IAAAA;MACA,KAAKoK;MACL,OAAO;QACL,GAAGpP;QACH,GAAG8P;QACH,SAAS;QACT,eAAe3S,MAAgB,eAAe,QAAQ;QACtD,UAAU;MAAA;MAGX,UAAAsK;IAAA;EAAA,EAAA,CAEL;AAEJ;AAGA4G,GAAM,cAAc;AC7Qb,SAAS6B,GACd/C,GACAgD,IAAqB,IACC;AACtB,MAAIC,IAAiC;AAErC,SAAO,CAAC9C,MAAe;AACjB8C,UAAY,QACd,aAAaA,CAAO,GAGtBA,IAAU,WAAW,MAAM;AACzBjD,QAAGG,CAAI;IACT,GAAG6C,CAAU;EACf;AACF;ACpBO,SAASE,GAAcrL,GAAYqG,GAA4B;AACpE,SAAO,0BAA0B,CAACrG,GAAI,GAAGqG,CAAQ,EAAE,KAAK,GAAG,CAAC;AAC9D;ACOO,SAASiF,GAAiB;EAC/B,gBAAAC,IAAiB;EACjB,UAAAlF;EACA,SAAAmF,IAAU;EACV,GAAG7B;AACL,GAmCG;AACD,QAAM8B,IAAcpF,MAAa,QAC3BrG,IAAK,QAAQ2J,IAAOA,EAAK,KAAKA,EAAK,SAEnC+B,IAAiBL,GAAcrL,GAAIqG,KAAY,CAAA,CAAE,GAKjDsF,QAAsBC,aAAAA;IAC1BC;IACA,MAAML,EAAQ,QAAQE,CAAc;IACpC,MAAMF,EAAQ,QAAQE,CAAc;EAAA,GAGhCxE,QAAgBoD,aAAAA;IACpB,MACEqB,IACK,KAAK,MAAMA,CAAmB,IAC/B;IACN,CAACA,CAAmB;EAAA,GAGhBG,QAAiBxB,aAAAA,SAA0C,MAAM;AACrE,UAAMyB,IAAa,CAAC7L,MAAmB;AACrC,UAAI8L;AACAP,UACFO,IAAkBX,GAAcrL,GAAI,OAAO,KAAKE,CAAM,CAAC,IAEvD8L,IAAkBX,GAAcrL,GAAI,CAAA,CAAE;AAGxC,UAAI;AACFwL,UAAQ,QAAQQ,GAAiB,KAAK,UAAU9L,CAAM,CAAC;MACzD,SAASlD,GAAO;AACd,gBAAQ,MAAMA,CAAK;MACrB;IACF;AAEA,WAAOuO,IAAiB,IACpBL,GAASa,GAAYR,CAAc,IACnCQ;EACN,GAAG,CAACR,GAAgBE,GAAazL,GAAIwL,CAAO,CAAC;AAE7C,SAAO;IACL,eAAAtE;IACA,gBAAA4E;EAAA;AAEJ;AAEA,SAASD,KAAY;AACnB,SAAO,WAAuB;EAAC;AACjC;AC7FO,SAASI,KAAsB;AACpC,aAAOzE,aAAAA,UAAuC,IAAI;AACpD;ACJO,SAAS0E,KAAc;AAC5B,aAAO7D,aAAAA,QAA8B,IAAI;AAC3C;ACJO,SAAS8D,KAAkB;AAChC,QAAM9B,QAAU+B,aAAAA,YAAWrD,EAAY;AACvC,SAAAjR;IACEuS;IACA;EAAA,GAGKA;AACT;ACHO,SAASgC,GAA0B;EACxC,SAAA/L;EACA,SAAAiG;AACF,GAG0B;AACxB,QAAMhG,IAAO,MAAM;AACjB,UAAM,EAAE,eAAAT,EAAA,IAAkBtC,EAAA;AAC1B,eAAW;MACTtF;MACA;QACE,uBAAAsI;QACA,yBAAAE;QACA,QAAAR;QACA,mBAAAS;MAAA;IACF,KACGb;AACH,UAAI5H,EAAM,OAAOoI;AACf,eAAO;UACL,uBAAAE;UACA,yBAAAE;UACA,OAAAxI;UACA,QAAAgI;UACA,mBAAAS;QAAA;AAKN,UAAM,MAAM,SAASL,CAAO,YAAY;EAC1C,GAEMgM,IAAsB,MAAM;AAChC,UAAMzI,IAAQtD,EAAAA,EAAO,wBAAwB;MAC3C,CAAChG,MAAYA,EAAQ,YAAYgM;IAAA;AAEnC,QAAI1C,MAAU;AACZ,aAAOA;AAGT,UAAM,MAAM,yCAAyC0C,CAAO,EAAE;EAChE,GAEMgG,IAAW,MAAM;AACrB,UAAM1I,IAAQtD,EAAAA,EAAO,MAAM,OAAO,KAAK,CAAChG,MAAYA,EAAQ,OAAOgM,CAAO;AAC1E,QAAI1C,MAAU;AACZ,aAAOA;AAGT,UAAM,MAAM,8BAA8B0C,CAAO,EAAE;EACrD,GAEMiG,IAAe,MAAM;AACzB,UAAM3I,IAAQtD,EAAAA,EAAO,OAAOgG,CAAO;AACnC,QAAI1C,MAAU;AACZ,aAAOA;AAGT,UAAM,MAAM,8BAA8B0C,CAAO,EAAE;EACrD,GAEMkG,IAAe,CAACvL,MAAqB;AACzC,UAAMlC,IAAWwN,EAAA;AACjB,QAAItL,MAAalC;AACf;AAGF,UAAM;MACJ,uBAAAwB;MACA,yBAAAE;MACA,OAAAxI;MACA,QAAQ2F;MACR,mBAAA8C;IAAA,IACEJ,EAAA,GAEEtD,IAAQ/E,EAAM,OAAO,UAAU,CAACqC,MAAYA,EAAQ,OAAOgM,CAAO,GAClEmG,IAAczP,MAAU/E,EAAM,OAAO,SAAS,GAE9CuI,IAAepC,EAAoB;MACvC,OAAOqO,IAAc1N,IAAWkC,IAAWA,IAAWlC;MACtD,eAAenB;MACf,kBAAkB6C;MAClB,cAAcgM,IAAc,CAACzP,IAAQ,GAAGA,CAAK,IAAI,CAACA,GAAOA,IAAQ,CAAC;MAClE,YAAAY;MACA,SAAS;IAAA,CACV,GAEKe,IAAaqB,EAAyB;MAC1C,QAAQQ;MACR,kBAAkBC;IAAA,CACnB;AACIX,MAAalC,GAAYe,CAAU,KACtCnB,EAAO,CAACE,OAAe;MACrB,eAAe,IAAI,IAAIA,EAAU,aAAa,EAAE,IAAIzF,GAAO;QACzD,uBAAAsI;QACA,yBAAAE;QACA,QAAQ9B;QACR,mBAAA+B;MAAA,CACD;IAAA,EACD;EAEN;AAEA,SAAO;IACL,UAAU,MAAM;AACd,YAAM,EAAE,aAAAxC,GAAa,eAAAjC,EAAA,IAAkBoQ,EAAA,GACjC,EAAE,eAAAK,EAAA,IAAkBJ,EAAA,GACpBjR,IAAOkR,EAAA;AAETrO,WAAe7C,MAASY,MAE1ByQ,EAAc,eAAerR,GAE7BmR,EAAavQ,CAAa;IAE9B;IACA,QAAQ,MAAM;AACZ,YAAM,EAAE,aAAAiC,GAAa,eAAAjC,GAAe,SAAAE,EAAA,IAAYkQ,EAAA,GAC1C,EAAE,eAAAK,EAAA,IAAkBJ,EAAA,GACpBjR,IAAOkR,EAAA;AAEb,UAAIrO,KAAe7C,MAASY,GAAe;AAEzC,YAAIgF,IAAWyL,EAAc,gBAAgBvQ;AAGzC8E,cAAa,MACfA,IAAW,IAGbuL,EAAavL,CAAQ;MACvB;IACF;IACA,SAAS,MAAM;AACb,YAAM,EAAE,OAAAhJ,EAAA,IAAUqI,EAAA,GACZqM,IAAeJ,EAAA,GACf,EAAE,SAAAxS,EAAA,IAAYuS,EAAA,GAEdM,IACJ3U,EAAM,gBAAgB,eAClB8B,EAAQ,cACRA,EAAQ;AAEd,aAAO;QACL,cAAA4S;QACA,UAAAC;MAAA;IAEJ;IACA,aAAa,MAAM;AACjB,YAAM,EAAE,aAAA1O,GAAa,eAAAjC,EAAA,IAAkBoQ,EAAA,GACjChR,IAAOkR,EAAA;AAEb,aAAOrO,KAAejB,EAAmBhB,GAAeZ,CAAI;IAC9D;IACA,QAAQ,CAACA,MAA0B;AAEjC,UADiBkR,EAAA,MACAlR,GAAM;AACrB,YAAIsR;AACJ,gBAAQ,OAAOtR,GAAA;UACb,KAAK,UAAU;AACb,kBAAM,EAAE,OAAApD,EAAA,IAAUqI,EAAA,GACZ9E,IAAYxD,EAA4B,EAAE,OAAAC,EAAAA,CAAO;AACvD0U,gBAAe9Q,EAAoBR,IAAOG,IAAa,GAAG;AAC1D;UACF;UACA,KAAK,UAAU;AACbmR,gBAAe,WAAWtR,CAAI;AAC9B;UACF;QAAA;AAGFmR,UAAaG,CAAY;MAC3B;IACF;EAAA;AAEJ;ACjLO,SAASE,GACdvG,GACAwG,GACA;AACA,QAAM,EAAE,IAAIzM,EAAA,IAAY6L,GAAA,GAElBa,QAAqB3E,aAAAA,QAA8B;IACvD,UAAU/G;IACV,QAAQA;IACR,SAAS,OAAO;MACd,cAAc;MACd,UAAU;IAAA;IAEZ,aAAa,MAAM;IACnB,QAAQA;EAAA,CACT;AAED8H,mBAAAA,qBAAoB2D,GAAU,MAAMC,EAAmB,SAAS,CAAA,CAAE,GAElEjF,EAA0B,MAAM;AAC9B,WAAO;MACLiF,EAAmB;MACnBX,GAA0B,EAAE,SAAA/L,GAAS,SAAAiG,EAAA,CAAS;IAAA;EAElD,CAAC;AACH;ACKO,SAAS0G,GAAM;EACpB,UAAAxK;EACA,WAAA6G;EACA,eAAApN,IAAgB;EAChB,aAAAiC,IAAc;EACd,aAAAhC;EACA,YAAYqN;EACZ,IAAIC;EACJ,SAAApN,IAAU;EACV,SAAAD,IAAU;EACV,UAAU8Q;EACV,UAAAH;EACA,OAAA/R;EACA,GAAG2O;AACL,GAAe;AACb,QAAMwD,IAAa,CAAC,CAAC1D,GAEfzJ,IAAK2H,GAAM8B,CAAM,GAEjBK,QAAazB,aAAAA,QAA8B,IAAI,GAE/C+B,IAAY7B,GAAcuB,GAAYN,CAAc,GAEpD,EAAE,IAAIlJ,GAAS,eAAA8M,EAAA,IAAkBjB,GAAA,GAEjCkB,IAAcH,MAAqB,MACnCI,IAAiBpF;IACrB,CACEqF,GACA7J,GACA8J,MACG;AACHN,UAAmBK,GAAW9D,GAAQ+D,CAAa;IACrD;EAAA;AAIFzF,IAA0B,MAAM;AAC9B,UAAM/N,IAAU8P,EAAW;AAC3B,QAAI9P,MAAY;AACd,aAAOoT,EAAc;QACnB,SAAApT;QACA,IAAAgG;QACA,YAAAmN;QACA,eAAe;UACb,cAAc;UACd,UAAU;QAAA;QAEZ,UAAUE,IAAcC,IAAiB;QACzC,kBAAkB;UAChB,eAAApR;UACA,aAAAiC;UACA,aAAAhC;UACA,SAAAE;UACA,SAAAD;QAAA;MACF,CACD;EAEL,GAAG;IACDF;IACAiC;IACAhC;IACAkR;IACArN;IACAmN;IACA9Q;IACAD;IACAkR;IACAF;EAAA,CACD,GAEDN,GAAyB9M,GAAI+M,CAAQ;AAErC,QAAMU,IAAc7E,GAA4BtI,GAASN,CAAE;AAE3D,aACEiL,mBAAAA;IAAC;IAAA;MACE,GAAGtB;MACJ,cAAU;MACV,eAAa3J;MACb,IAAAA;MACA,KAAKoK;MACL,OAAO;QACL,GAAGsD;QAEH,WAAW;QACX,UAAU,OAAOD,CAAW;QAC5B,YAAY;;QAGZ,UAAU;;;QAIV,eACE,OAAO9E,EAAgC;MAAA;MAG3C,cAAAsC,mBAAAA;QAAC;QAAA;UACC,WAAA3B;UACA,OAAO;YACL,OAAO;YACP,QAAQ;YACR,GAAGtO;UAAA;UAGJ,UAAAyH;QAAA;MAAA;IACH;EAAA;AAGN;AAGAwK,GAAM,cAAc;AAEpB,IAAMS,KAA2C;EAC/C,WAAW;EACX,WAAW;EACX,QAAQ;EAER,UAAU;EACV,UAAU;EACV,OAAO;EAEP,MAAM;EACN,WAAW;EACX,YAAY;EACZ,UAAU;EAEV,QAAQ;EACR,aAAa;EACb,SAAS;EACT,QAAQ;AACV;AClKO,SAASC,KAAsB;AACpC,aAAOnG,aAAAA,UAAuC,IAAI;AACpD;ACJO,SAASoG,KAAc;AAC5B,aAAOvF,aAAAA,QAA8B,IAAI;AAC3C;ACHO,SAASwF,GAA6B;EAC3C,QAAA3N;EACA,kBAAAjE;EACA,SAAAsK;EACA,YAAAuH;AACF,GAUE;AACA,MAAIC,GACAC;AAEJ,QAAMT,IAAYrN,EAAOqG,CAAO,GAE1B3I,IAAc3B,EAAiB;IACnC,CAAC1B,MAAYA,EAAQ,YAAYgM;EAAA;AAEnC,MAAI3I,GAAa;AACf,UAAMvB,IAAUuB,EAAY,SACtBxB,IAAW4R,IAAWpQ,EAAY,cACpCA,EAAY,gBACZA,EAAY,SAEVY,IAAe,CAACsP,GAAYA,IAAa,CAAC;AAchDE,QAZsB/N,EAAyB;MAC7C,QAAQ5B,EAAoB;QAC1B,OAAOjC,IAAUmR;QACjB,eAAerN;QACf,kBAAAjE;QACA,cAAAuC;QACA,YAAY0B;QACZ,SAAS;MAAA,CACV;MACD,kBAAAjE;IAAA,CACD,EAEwBsK,CAAO,GAchCwH,IAZsB9N,EAAyB;MAC7C,QAAQ5B,EAAoB;QAC1B,OAAOhC,IAAUkR;QACjB,eAAerN;QACf,kBAAAjE;QACA,cAAAuC;QACA,YAAY0B;QACZ,SAAS;MAAA,CACV;MACD,kBAAAjE;IAAA,CACD,EAEwBsK,CAAO;EAClC;AAEA,SAAO;IACL,eAAeA;IACf,UAAAwH;IACA,UAAAC;IACA,UAAUT;EAAA;AAEd;AC7CO,SAASU,GAAU;EACxB,UAAAxL;EACA,WAAA6G;EACA,YAAYE;EACZ,IAAIC;EACJ,OAAAzO;EACA,GAAG2O;AACL,GAAmB;AACjB,QAAM3J,IAAK2H,GAAM8B,CAAM,GAEjB,CAACyE,GAAMC,CAAO,QAAI3G,aAAAA,UAKrB,CAAA,CAAE,GAEC,CAAC4G,GAAWC,CAAY,QAC5B7G,aAAAA,UAAoC,UAAU,GAE1CsC,QAAazB,aAAAA,QAA8B,IAAI,GAE/C+B,IAAY7B,GAAcuB,GAAYN,CAAc,GAEpD;IACJ,IAAIlJ;IACJ,aAAagO;IACb,mBAAAC;EAAA,IACEpC,GAAA,GAEEhU,IACJmW,MAAqB,eAAe,aAAa;AAInD,SAAAvG,EAA0B,MAAM;AAC9B,UAAM/N,IAAU8P,EAAW;AAC3B,QAAI9P,MAAY,MAAM;AACpB,YAAMY,IAAiC;QACrC,SAAAZ;QACA,IAAAgG;MAAA,GAGIwO,IAAsBD,EAAkB3T,CAAS,GAEjD+P,IAAuCpN,EAAa;QACxD;QACA,CAACwH,MAAqB;AACpBsJ;YACEtJ,EAAiB,UAAU,cACzBA,EAAiB,WAAW;cAC1B,CAACjD,MAAcA,EAAU,cAAclH;YAAA,IAEvCmK,EAAiB,QACjB;UAAA;QAER;MAAA,GAGI0J,IAAoClR,EAAa;QACrD;QACA,CAACuC,MAAkB;AACjBA,YAAc;YACZ,CACE,EAAE,yBAAAY,GAAyB,QAAAR,GAAQ,mBAAAS,EAAA,GACnCE,MACG;AACH,kBAAIA,EAAa,OAAOP,GAAS;AAC/B,sBAAMlI,IAASuI,EAAkB,IAAI/F,CAAS;AAC9C,oBAAIxC,GAAQ;AACV,wBAAM6I,IAAe7I,EAAO,CAAC,GACvB0V,IAAajN,EAAa,OAAO,QAAQI,CAAY;AAE3DkN;oBACEN,GAA6B;sBAC3B,QAAA3N;sBACA,kBAAkBQ;sBAClB,SAASO,EAAa;sBACtB,YAAA6M;oBAAA,CACD;kBAAA;gBAEL;cACF;YACF;UAAA;QAEJ;MAAA;AAGF,aAAO,MAAM;AACXnD,UAAA,GACA8D,EAAA,GACAD,EAAA;MACF;IACF;EACF,GAAG,CAAClO,GAASN,GAAIuO,CAAiB,CAAC,OAGjCtD,mBAAAA;IAAC;IAAA;MACE,GAAGtB;MACJ,iBAAeuE,EAAK;MACpB,oBAAkB/V;MAClB,iBAAe+V,EAAK;MACpB,iBAAeA,EAAK;MACpB,iBAAeA,EAAK;MACpB,UAAAzL;MACA,WAAA6G;MACA,kBAAgB8E;MAChB,eAAapO;MACb,IAAAA;MACA,KAAKoK;MACL,MAAK;MACL,OAAO;QACL,WAAW;QACX,GAAGpP;QACH,UAAU;QACV,YAAY;MAAA;MAEd,UAAU;IAAA;EAAA;AAGhB;AAGAiT,GAAU,cAAc;",
  "names": ["assert", "expectedCondition", "message", "calculateAvailableGroupSize", "group", "orientation", "panels", "totalSize", "panel", "sortByElementOffset", "panelsOrSeparators", "horizontalSort", "verticalSort", "a", "b", "delta", "isHTMLElement", "value", "getDistanceBetweenPointAndRect", "point", "rect", "findClosestRect", "rects", "targetRect", "centerPoint", "closestRect", "minDistance", "x", "y", "distance", "calculateHitRegions", "groupElement", "separators", "sortedChildElements", "element", "hitRegions", "hasInterleavedStaticContent", "prevPanel", "pendingSeparators", "childElement", "panelData", "current", "prevRect", "pendingRectsOrSeparators", "firstPanelEdgeRect", "secondPanelEdgeRect", "separator", "rectOrSeparator", "separatorData", "convertEmToPixels", "style", "fontSize", "convertRemToPixels", "convertVhToPixels", "convertVwToPixels", "parseSizeAndUnit", "size", "numeric", "sizeStyleToPixels", "groupSize", "panelElement", "styleProp", "pixels", "unit", "formatLayoutNumber", "number", "calculatePanelConstraints", "panelConstraints", "collapsedSize", "defaultSize", "minSize", "maxSize", "EventEmitter", "#listenerMap", "type", "listener", "listeners", "data", "didThrow", "caughtError", "clonedListeners", "i", "error", "index", "layoutNumbersEqual", "actual", "expected", "minimumDelta", "state", "eventEmitter", "read", "update", "partialState", "prevState", "constraints", "prevLayout", "isCollapsed", "wasCollapsed", "isArrayEqual", "compareLayoutNumbers", "validatePanelSize", "collapsible", "halfwayPoint", "adjustLayoutByDelta", "initialLayoutProp", "panelConstraintsArray", "pivotIndices", "prevLayoutProp", "trigger", "initialLayout", "nextLayout", "firstPivotIndex", "secondPivotIndex", "deltaApplied", "prevSize", "localDelta", "increment", "maxAvailableDelta", "minAbsDelta", "deltaRemaining", "unsafeSize", "safeSize", "pivotIndex", "total", "prevLayoutKeys", "accumulated", "findSeparatorGroup", "separatorElement", "mountedGroups", "layoutsEqual", "id", "validatePanelGroupLayout", "layout", "nextLayoutTotalSize", "remainingSize", "getImperativeGroupMethods", "groupId", "find", "defaultLayoutDeferred", "unsafeLayout", "derivedPanelConstraints", "separatorToPanels", "getMountedGroup", "mountedGroup", "adjustLayoutForSeparator", "onDocumentKeyDown", "event", "primaryPanel", "nextSize", "separatorElements", "nextIndex", "IDENTITY_FUNCTION", "NOOP_FUNCTION", "CURSOR_FLAG_HORIZONTAL_MIN", "CURSOR_FLAG_HORIZONTAL_MAX", "CURSOR_FLAG_VERTICAL_MIN", "CURSOR_FLAG_VERTICAL_MAX", "DEFAULT_POINTER_PRECISION", "findClosetHitRegion", "closestHitRegion", "hitRegion", "cached", "isCoarsePointer", "isShadowRoot", "compare", "ancestors", "get_ancestors", "common_ancestor", "z_indexes", "get_z_index", "find_stacking_context", "children", "furthest_ancestors", "child", "props", "is_flex_item", "node", "display", "get_parent", "creates_stacking_context", "nodes", "parentNode", "doRectsIntersect", "isViableHitTarget", "pointerEventTarget", "currentElement", "findMatchingHitRegions", "matchingHitRegions", "_", "groupData", "maxDistance", "match", "onDocumentPointerDown", "groups", "initialLayoutMap", "didChangeFocus", "getCursorStyle", "cursorFlags", "horizontalCount", "verticalCount", "horizontalMin", "horizontalMax", "verticalMin", "verticalMax", "documentToStyleMap", "updateCursorStyle", "ownerDocument", "prevStyle", "styleSheet", "interactionState", "cursorStyle", "nextStyle", "updateActiveHitRegions", "document", "pointerDownAtPoint", "nextMountedGroups", "disableCursor", "deltaAsPercentage", "panelIdsKey", "onDocumentPointerLeave", "onDocumentPointerMove", "onDocumentPointerUp", "calculateDefaultLayout", "explicitCount", "remainingPanelCount", "notifyPanelOnResize", "borderBoxSize", "resizeObserverSize", "objectsEqual", "key", "validateLayoutKeys", "panelIds", "layoutKeys", "panelId", "ownerDocumentReferenceCounts", "mountGroup", "isMounted", "ResizeObserver", "separatorIds", "resizeObserver", "entries", "entry", "target", "nextDerivedPanelConstraints", "defaultLayout", "defaultLayoutUnsafe", "defaultLayoutSafe", "useForceUpdate", "sigil", "setSigil", "useState", "forceUpdate", "useCallback", "useId", "stableId", "dynamicId", "useIdReact", "useIsomorphicLayoutEffect", "useLayoutEffect", "useEffect", "useStableCallback", "fn", "ref", "useRef", "args", "useMergedRefs", "refs", "useStableObject", "unstableObject", "POINTER_EVENTS_CSS_PROPERTY_NAME", "getPanelSizeCssPropertyName", "groupIdEscaped", "panelIdEscaped", "GroupContext", "createContext", "useGroupImperativeHandle", "groupRef", "imperativeGroupRef", "useImperativeHandle", "Group", "className", "disabled", "elementRefProp", "idProp", "onLayoutChangeUnstable", "rest", "prevLayoutRef", "onLayoutChangeStable", "elementRef", "dragActive", "setDragActive", "setLayout", "panelOrSeparatorChangeSigil", "inMemoryValuesRef", "mergedRef", "context", "useMemo", "inMemoryValues", "stableProps", "registeredGroupRef", "unmountGroup", "removeInteractionStateChangeListener", "removeMountedGroupsChangeEventListener", "registeredGroup", "cssVariables", "propertyName", "flexGrow", "jsx", "debounce", "durationMs", "timeout", "getStorageKey", "useDefaultLayout", "debounceSaveMs", "storage", "hasPanelIds", "readStorageKey", "defaultLayoutString", "useSyncExternalStore", "subscribe", "onLayoutChange", "saveLayout", "writeStorageKey", "useGroupCallbackRef", "useGroupRef", "useGroupContext", "useContext", "getImperativePanelMethods", "getPanelConstraints", "getPanel", "getPanelSize", "setPanelSize", "isLastPanel", "mutableValues", "asPercentage", "inPixels", "usePanelImperativeHandle", "panelRef", "imperativePanelRef", "Panel", "onResizeUnstable", "idIsStable", "registerPanel", "hasOnResize", "onResizeStable", "panelSize", "prevPanelSize", "flexGrowVar", "PROHIBITED_CSS_PROPERTIES", "usePanelCallbackRef", "usePanelRef", "calculateSeparatorAriaValues", "panelIndex", "valueMax", "valueMin", "Separator", "aria", "setAria", "dragState", "setDragState", "groupOrientation", "registerSeparator", "unregisterSeparator", "removeMountedGroupsChangeListener"]
}
